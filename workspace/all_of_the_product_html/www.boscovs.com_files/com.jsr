
/*  ## Emitted on: Tue Dec  2 22:54:20 2014  (0.11682403469144)## */
//provides com.liquidpixels.copyright
//EOResources

// ---------------------------------------------------------------------------
//    Copyright (c) 2013, LiquidPixels, Incorporated. All Rights Reserved.
//
//    This file represents Intellectual Property which is proprietary and
//  confidential to LiquidPixels, Incorporated. Any disclosure, in whole
//  or in part, is prohibited without express written permission.
//
//   $Id: copyright.js 5856 2013-09-19 19:54:45Z jagosta $
// ---------------------------------------------------------------------------

// ----------------------------
// Portions of this file include:
// org.prototypejs.prototype

/*  Prototype JavaScript framework, version 1.6.0.1
 *  (c) 2005-2007 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 */

// ----------------------------
// Portions of this file may include:
// us.aculo.scriptaculous.Scriptaculous

// script.aculo.us scriptaculous.js v1.8.1, Thu Jan 03 22:07:12 -0500 2008
// Copyright (c) 2005-2007 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// For details, see the script.aculo.us web site: http://script.aculo.us/
// ----------------------------

// All other code:
//  Copyright (c) 2013, LiquidPixels, Incorporated. All Rights Reserved.


/**
 * JustGage - a handy JavaScript plugin for generating and animating nice & clean dashboard gauges.
 * Copyright (c) 2012 Bojan Djuricic - pindjur(at)gmail(dot)com | http://www.madcog.com
 * Licensed under MIT.
 * Date: 31/07/2012
 * @author Bojan Djuricic  (@Toorshia)
 * @version 1.0
 *
 * http://www.justgage.com
 */

/**
 ** More info at http://www.opentip.org
 **
 ** Copyright (c) 2009, Matias Meno
 ** Graphics by Tjandra Mayerhold
 **
 ** Permission is hereby granted, free of charge, to any person obtaining a copy
 ** of this software and associated documentation files (the "Software"), to deal
 ** in the Software without restriction, including without limitation the rights
 ** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 ** copies of the Software, and to permit persons to whom the Software is
 ** furnished to do so, subject to the following conditions:
 **
 ** The above copyright notice and this permission notice shall be included in
 ** all copies or substantial portions of the Software.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 ** THE SOFTWARE.
 **
 **/



if(!window.com) {window.com = {}};
if(!com.liquidpixels) {com.liquidpixels = {}};
if(!com.liquidpixels.utilities) {com.liquidpixels.utilities = {}};
if(!com.liquidpixels.utilities.Truth) {com.liquidpixels.utilities.Truth = {}};
if(!com.liquidpixels.ResourceServer) {com.liquidpixels.ResourceServer = {}};
if(!com.liquidpixels.ResourceServer.Loaded) {com.liquidpixels.ResourceServer.Loaded = {}};
if(!com.liquidpixels.ResourceServer.Loaded.script) {com.liquidpixels.ResourceServer.Loaded.script = {}};
if(!com.liquidpixels.liquifire) {com.liquidpixels.liquifire = {}};
if(!com.liquidpixels.motion) {com.liquidpixels.motion = {}};
if(!com.liquidpixels.magnify) {com.liquidpixels.magnify = {}};
if(!com.liquidpixels.event) {com.liquidpixels.event = {}};
if(!com.liquidpixels.event.EventManageable) {com.liquidpixels.event.EventManageable = {}};
if(!com.liquidpixels.utilities.DeepMerge) {com.liquidpixels.utilities.DeepMerge = {}};
if(!com.liquidpixels.event.EventDispatcher) {com.liquidpixels.event.EventDispatcher = {}};
if(!com.liquidpixels.wui) {com.liquidpixels.wui = {}};
if(!com.liquidpixels.utilities.Type) {com.liquidpixels.utilities.Type = {}};
if(!com.liquidpixels.application) {com.liquidpixels.application = {}};
if(!com.liquidpixels.ResourceServer.Flags) {com.liquidpixels.ResourceServer.Flags = {}};

if(!com.liquidpixels.ResourceServer.Flags['com.liquidpixels.magnify']) {com.liquidpixels.ResourceServer.Flags['com.liquidpixels.magnify'] = {}};
com.liquidpixels.ResourceServer.Flags['com.liquidpixels.magnify']['version'] = "2.1.1-1";

if(!com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html']) {com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html'] = {}};
com.liquidpixels.ResourceServer.Flags['com.liquidpixels.viewers-html']['version'] = "2.1.0-1";

com.liquidpixels.ResourceServer.Loaded['script']['com.liquidpixels.Magnify'] = true;
com.liquidpixels.ResourceServer.Version = '%{LPI_VERSION}';


var Prototype = {
Version: '1.7.1',
Browser: (function(){
var ua = navigator.userAgent;
var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
return {
IE:             !!window.attachEvent && !isOpera,
Opera:          isOpera,
WebKit:         ua.indexOf('AppleWebKit/') > -1,
Gecko:          ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
MobileSafari:   /Apple.*Mobile/.test(ua)}
})(),
BrowserFeatures: {
XPath: !!document.evaluate,
SelectorsAPI: !!document.querySelector,
ElementExtensions: (function() {
var constructor = window.Element || window.HTMLElement;
return !!(constructor && constructor.prototype);
})(),
SpecificElementExtensions: (function() {
if (typeof window.HTMLDivElement !== 'undefined')
return true;
var div = document.createElement('div'),
form = document.createElement('form'),
isSupported = false;
if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
isSupported = true;}
div = form = null;
return isSupported;
})()},
ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script\\s*>',
JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
emptyFunction: function() { },
K: function(x) { return x }};
if (Prototype.Browser.MobileSafari)
Prototype.BrowserFeatures.SpecificElementExtensions = false;
var Class = (function() {
var IS_DONTENUM_BUGGY = (function(){
for (var p in { toString: 1 }) {
if (p === 'toString') return false;}
return true;
})();
function subclass() {};
function create() {
var parent = null, properties = $A(arguments);
if (Object.isFunction(properties[0]))
parent = properties.shift();
function klass() {
this.initialize.apply(this, arguments);}
Object.extend(klass, Class.Methods);
klass.superclass = parent;
klass.subclasses = [];
if (parent) {
subclass.prototype = parent.prototype;
klass.prototype = new subclass;
parent.subclasses.push(klass);}
for (var i = 0, length = properties.length; i < length; i++)
klass.addMethods(properties[i]);
if (!klass.prototype.initialize)
klass.prototype.initialize = Prototype.emptyFunction;
klass.prototype.constructor = klass;
return klass;}
function addMethods(source) {
var ancestor   = this.superclass && this.superclass.prototype,
properties = Object.keys(source);
if (IS_DONTENUM_BUGGY) {
if (source.toString != Object.prototype.toString)
properties.push("toString");
if (source.valueOf != Object.prototype.valueOf)
properties.push("valueOf");}
for (var i = 0, length = properties.length; i < length; i++) {
var property = properties[i], value = source[property];
if (ancestor && Object.isFunction(value) &&
value.argumentNames()[0] == "$super") {
var method = value;
value = (function(m) {
return function() { return ancestor[m].apply(this, arguments); };
})(property).wrap(method);
value.valueOf = (function(method) {
return function() { return method.valueOf.call(method); };
})(method);
value.toString = (function(method) {
return function() { return method.toString.call(method); };
})(method);}
this.prototype[property] = value;}
return this;}
return {
create: create,
Methods: {
addMethods: addMethods}};
})();
(function() {
var _toString = Object.prototype.toString,
_hasOwnProperty = Object.prototype.hasOwnProperty,
NULL_TYPE = 'Null',
UNDEFINED_TYPE = 'Undefined',
BOOLEAN_TYPE = 'Boolean',
NUMBER_TYPE = 'Number',
STRING_TYPE = 'String',
OBJECT_TYPE = 'Object',
FUNCTION_CLASS = '[object Function]',
BOOLEAN_CLASS = '[object Boolean]',
NUMBER_CLASS = '[object Number]',
STRING_CLASS = '[object String]',
ARRAY_CLASS = '[object Array]',
DATE_CLASS = '[object Date]',
NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &&
typeof JSON.stringify === 'function' &&
JSON.stringify(0) === '0' &&
typeof JSON.stringify(Prototype.K) === 'undefined';
var DONT_ENUMS = ['toString', 'toLocaleString', 'valueOf',
'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
var IS_DONTENUM_BUGGY = (function(){
for (var p in { toString: 1 }) {
if (p === 'toString') return false;}
return true;
})();
function Type(o) {
switch(o) {
case null: return NULL_TYPE;
case (void 0): return UNDEFINED_TYPE;}
var type = typeof o;
switch(type) {
case 'boolean': return BOOLEAN_TYPE;
case 'number':  return NUMBER_TYPE;
case 'string':  return STRING_TYPE;}
return OBJECT_TYPE;}
function extend(destination, source) {
for (var property in source)
destination[property] = source[property];
return destination;}
function inspect(object) {
try {
if (isUndefined(object)) return 'undefined';
if (object === null) return 'null';
return object.inspect ? object.inspect() : String(object);
} catch (e) {
if (e instanceof RangeError) return '...';
throw e;}}
function toJSON(value) {
return Str('', { '': value }, []);}
function Str(key, holder, stack) {
var value = holder[key];
if (Type(value) === OBJECT_TYPE && typeof value.toJSON === 'function') {
value = value.toJSON(key);}
var _class = _toString.call(value);
switch (_class) {
case NUMBER_CLASS:
case BOOLEAN_CLASS:
case STRING_CLASS:
value = value.valueOf();}
switch (value) {
case null: return 'null';
case true: return 'true';
case false: return 'false';}
var type = typeof value;
switch (type) {
case 'string':
return value.inspect(true);
case 'number':
return isFinite(value) ? String(value) : 'null';
case 'object':
for (var i = 0, length = stack.length; i < length; i++) {
if (stack[i] === value) {
throw new TypeError("Cyclic reference to '" + value + "' in object");}}
stack.push(value);
var partial = [];
if (_class === ARRAY_CLASS) {
for (var i = 0, length = value.length; i < length; i++) {
var str = Str(i, value, stack);
partial.push(typeof str === 'undefined' ? 'null' : str);}
partial = '[' + partial.join(',') + ']';
} else {
var keys = Object.keys(value);
for (var i = 0, length = keys.length; i < length; i++) {
var key = keys[i], str = Str(key, value, stack);
if (typeof str !== "undefined") {
partial.push(key.inspect(true)+ ':' + str);}}
partial = '{' + partial.join(',') + '}';}
stack.pop();
return partial;}}
function stringify(object) {
return JSON.stringify(object);}
function toQueryString(object) {
return $H(object).toQueryString();}
function toHTML(object) {
return object && object.toHTML ? object.toHTML() : String.interpret(object);}
function keys(object) {
if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
var results = [];
for (var property in object) {
if (_hasOwnProperty.call(object, property))
results.push(property);}
if (IS_DONTENUM_BUGGY) {
for (var i = 0; property = DONT_ENUMS[i]; i++) {
if (_hasOwnProperty.call(object, property))
results.push(property);}}
return results;}
function values(object) {
var results = [];
for (var property in object)
results.push(object[property]);
return results;}
function clone(object) {
return extend({ }, object);}
function isElement(object) {
return !!(object && object.nodeType == 1);}
function isArray(object) {
return _toString.call(object) === ARRAY_CLASS;}
var hasNativeIsArray = (typeof Array.isArray == 'function')
&& Array.isArray([]) && !Array.isArray({});
if (hasNativeIsArray) {
isArray = Array.isArray;}
function isHash(object) {
return object instanceof Hash;}
function isFunction(object) {
return _toString.call(object) === FUNCTION_CLASS;}
function isString(object) {
return _toString.call(object) === STRING_CLASS;}
function isNumber(object) {
return _toString.call(object) === NUMBER_CLASS;}
function isDate(object) {
return _toString.call(object) === DATE_CLASS;}
function isUndefined(object) {
return typeof object === "undefined";}
extend(Object, {
extend:        extend,
inspect:       inspect,
toJSON:        NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
toQueryString: toQueryString,
toHTML:        toHTML,
keys:          Object.keys || keys,
values:        values,
clone:         clone,
isElement:     isElement,
isArray:       isArray,
isHash:        isHash,
isFunction:    isFunction,
isString:      isString,
isNumber:      isNumber,
isDate:        isDate,
isUndefined:   isUndefined});
})();
Object.extend(Function.prototype, (function() {
var slice = Array.prototype.slice;
function update(array, args) {
var arrayLength = array.length, length = args.length;
while (length--) array[arrayLength + length] = args[length];
return array;}
function merge(array, args) {
array = slice.call(array, 0);
return update(array, args);}
function argumentNames() {
var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
.replace(/\s+/g, '').split(',');
return names.length == 1 && !names[0] ? [] : names;}
function bind(context) {
if (arguments.length < 2 && Object.isUndefined(arguments[0]))
return this;
if (!Object.isFunction(this))
throw new TypeError("The object is not callable.");
var nop = function() {};
var __method = this, args = slice.call(arguments, 1);
var bound = function() {
var a = merge(args, arguments), c = context;
var c = this instanceof bound ? this : context;
return __method.apply(c, a);};
nop.prototype   = this.prototype;
bound.prototype = new nop();
return bound;}
function bindAsEventListener(context) {
var __method = this, args = slice.call(arguments, 1);
return function(event) {
var a = update([event || window.event], args);
return __method.apply(context, a);}}
function curry() {
if (!arguments.length) return this;
var __method = this, args = slice.call(arguments, 0);
return function() {
var a = merge(args, arguments);
return __method.apply(this, a);}}
function delay(timeout) {
var __method = this, args = slice.call(arguments, 1);
timeout = timeout * 1000;
return window.setTimeout(function() {
return __method.apply(__method, args);
}, timeout);}
function defer() {
var args = update([0.01], arguments);
return this.delay.apply(this, args);}
function wrap(wrapper) {
var __method = this;
return function() {
var a = update([__method.bind(this)], arguments);
return wrapper.apply(this, a);}}
function methodize() {
if (this._methodized) return this._methodized;
var __method = this;
return this._methodized = function() {
var a = update([this], arguments);
return __method.apply(null, a);};}
var extensions = {
argumentNames:       argumentNames,
bindAsEventListener: bindAsEventListener,
curry:               curry,
delay:               delay,
defer:               defer,
wrap:                wrap,
methodize:           methodize};
if (!Function.prototype.bind)
extensions.bind = bind;
return extensions;
})());
(function(proto) {
function toISOString() {
return this.getUTCFullYear() + '-' +
(this.getUTCMonth() + 1).toPaddedString(2) + '-' +
this.getUTCDate().toPaddedString(2) + 'T' +
this.getUTCHours().toPaddedString(2) + ':' +
this.getUTCMinutes().toPaddedString(2) + ':' +
this.getUTCSeconds().toPaddedString(2) + 'Z';}
function toJSON() {
return this.toISOString();}
if (!proto.toISOString) proto.toISOString = toISOString;
if (!proto.toJSON) proto.toJSON = toJSON;
})(Date.prototype);
RegExp.prototype.match = RegExp.prototype.test;
RegExp.escape = function(str) {
return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');};
var PeriodicalExecuter = Class.create({
initialize: function(callback, frequency) {
this.callback = callback;
this.frequency = frequency;
this.currentlyExecuting = false;
this.registerCallback();},
registerCallback: function() {
this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);},
execute: function() {
this.callback(this);},
stop: function() {
if (!this.timer) return;
clearInterval(this.timer);
this.timer = null;},
onTimerEvent: function() {
if (!this.currentlyExecuting) {
try {
this.currentlyExecuting = true;
this.execute();
this.currentlyExecuting = false;
} catch(e) {
this.currentlyExecuting = false;
throw e;}}}});
Object.extend(String, {
interpret: function(value) {
return value == null ? '' : String(value);},
specialChar: {
'\b': '\\b',
'\t': '\\t',
'\n': '\\n',
'\f': '\\f',
'\r': '\\r',
'\\': '\\\\'}});
Object.extend(String.prototype, (function() {
var NATIVE_JSON_PARSE_SUPPORT = window.JSON &&
typeof JSON.parse === 'function' &&
JSON.parse('{"test": true}').test;
function prepareReplacement(replacement) {
if (Object.isFunction(replacement)) return replacement;
var template = new Template(replacement);
return function(match) { return template.evaluate(match) };}
function gsub(pattern, replacement) {
var result = '', source = this, match;
replacement = prepareReplacement(replacement);
if (Object.isString(pattern))
pattern = RegExp.escape(pattern);
if (!(pattern.length || pattern.source)) {
replacement = replacement('');
return replacement + source.split('').join(replacement) + replacement;}
while (source.length > 0) {
if (match = source.match(pattern)) {
result += source.slice(0, match.index);
result += String.interpret(replacement(match));
source  = source.slice(match.index + match[0].length);
} else {
result += source, source = '';}}
return result;}
function sub(pattern, replacement, count) {
replacement = prepareReplacement(replacement);
count = Object.isUndefined(count) ? 1 : count;
return this.gsub(pattern, function(match) {
if (--count < 0) return match[0];
return replacement(match);});}
function scan(pattern, iterator) {
this.gsub(pattern, iterator);
return String(this);}
function truncate(length, truncation) {
length = length || 30;
truncation = Object.isUndefined(truncation) ? '...' : truncation;
return this.length > length ?
this.slice(0, length - truncation.length) + truncation : String(this);}
function strip() {
return this.replace(/^\s+/, '').replace(/\s+$/, '');}
function stripTags() {
return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');}
function stripScripts() {
return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');}
function extractScripts() {
var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
matchOne = new RegExp(Prototype.ScriptFragment, 'im');
return (this.match(matchAll) || []).map(function(scriptTag) {
return (scriptTag.match(matchOne) || ['', ''])[1];});}
function evalScripts() {
return this.extractScripts().map(function(script) { return eval(script); });}
function escapeHTML() {
return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
function unescapeHTML() {
return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');}
function toQueryParams(separator) {
var match = this.strip().match(/([^?#]*)(#.*)?$/);
if (!match) return { };
return match[1].split(separator || '&').inject({ }, function(hash, pair) {
if ((pair = pair.split('='))[0]) {
var key = decodeURIComponent(pair.shift()),
value = pair.length > 1 ? pair.join('=') : pair[0];
if (value != undefined) value = decodeURIComponent(value);
if (key in hash) {
if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
hash[key].push(value);}
else hash[key] = value;}
return hash;});}
function toArray() {
return this.split('');}
function succ() {
return this.slice(0, this.length - 1) +
String.fromCharCode(this.charCodeAt(this.length - 1) + 1);}
function times(count) {
return count < 1 ? '' : new Array(count + 1).join(this);}
function camelize() {
return this.replace(/-+(.)?/g, function(match, chr) {
return chr ? chr.toUpperCase() : '';});}
function capitalize() {
return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();}
function underscore() {
return this.replace(/::/g, '/')
.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
.replace(/([a-z\d])([A-Z])/g, '$1_$2')
.replace(/-/g, '_')
.toLowerCase();}
function dasherize() {
return this.replace(/_/g, '-');}
function inspect(useDoubleQuotes) {
var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
if (character in String.specialChar) {
return String.specialChar[character];}
return '\\u00' + character.charCodeAt().toPaddedString(2, 16);});
if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
return "'" + escapedString.replace(/'/g, '\\\'') + "'";}
function unfilterJSON(filter) {
return this.replace(filter || Prototype.JSONFilter, '$1');}
function isJSON() {
var str = this;
if (str.blank()) return false;
str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
return (/^[\],:{}\s]*$/).test(str);}
function evalJSON(sanitize) {
var json = this.unfilterJSON(),
cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
if (cx.test(json)) {
json = json.replace(cx, function (a) {
return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);});}
try {
if (!sanitize || json.isJSON()) return eval('(' + json + ')');
} catch (e) { }
throw new SyntaxError('Badly formed JSON string: ' + this.inspect());}
function parseJSON() {
var json = this.unfilterJSON();
return JSON.parse(json);}
function include(pattern) {
return this.indexOf(pattern) > -1;}
function startsWith(pattern) {
return this.lastIndexOf(pattern, 0) === 0;}
function endsWith(pattern) {
var d = this.length - pattern.length;
return d >= 0 && this.indexOf(pattern, d) === d;}
function empty() {
return this == '';}
function blank() {
return /^\s*$/.test(this);}
function interpolate(object, pattern) {
return new Template(this, pattern).evaluate(object);}
return {
gsub:           gsub,
sub:            sub,
scan:           scan,
truncate:       truncate,
strip:          String.prototype.trim || strip,
stripTags:      stripTags,
stripScripts:   stripScripts,
extractScripts: extractScripts,
evalScripts:    evalScripts,
escapeHTML:     escapeHTML,
unescapeHTML:   unescapeHTML,
toQueryParams:  toQueryParams,
parseQuery:     toQueryParams,
toArray:        toArray,
succ:           succ,
times:          times,
camelize:       camelize,
capitalize:     capitalize,
underscore:     underscore,
dasherize:      dasherize,
inspect:        inspect,
unfilterJSON:   unfilterJSON,
isJSON:         isJSON,
evalJSON:       NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
include:        include,
startsWith:     startsWith,
endsWith:       endsWith,
empty:          empty,
blank:          blank,
interpolate:    interpolate};
})());
var Template = Class.create({
initialize: function(template, pattern) {
this.template = template.toString();
this.pattern = pattern || Template.Pattern;},
evaluate: function(object) {
if (object && Object.isFunction(object.toTemplateReplacements))
object = object.toTemplateReplacements();
return this.template.gsub(this.pattern, function(match) {
if (object == null) return (match[1] + '');
var before = match[1] || '';
if (before == '\\') return match[2];
var ctx = object, expr = match[3],
pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
match = pattern.exec(expr);
if (match == null) return before;
while (match != null) {
var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
ctx = ctx[comp];
if (null == ctx || '' == match[3]) break;
expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
match = pattern.exec(expr);}
return before + String.interpret(ctx);});}});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
var $break = { };
var Enumerable = (function() {
function each(iterator, context) {
try {
this._each(iterator, context);
} catch (e) {
if (e != $break) throw e;}
return this;}
function eachSlice(number, iterator, context) {
var index = -number, slices = [], array = this.toArray();
if (number < 1) return array;
while ((index += number) < array.length)
slices.push(array.slice(index, index+number));
return slices.collect(iterator, context);}
function all(iterator, context) {
iterator = iterator || Prototype.K;
var result = true;
this.each(function(value, index) {
result = result && !!iterator.call(context, value, index, this);
if (!result) throw $break;
}, this);
return result;}
function any(iterator, context) {
iterator = iterator || Prototype.K;
var result = false;
this.each(function(value, index) {
if (result = !!iterator.call(context, value, index, this))
throw $break;
}, this);
return result;}
function collect(iterator, context) {
iterator = iterator || Prototype.K;
var results = [];
this.each(function(value, index) {
results.push(iterator.call(context, value, index, this));
}, this);
return results;}
function detect(iterator, context) {
var result;
this.each(function(value, index) {
if (iterator.call(context, value, index, this)) {
result = value;
throw $break;}
}, this);
return result;}
function findAll(iterator, context) {
var results = [];
this.each(function(value, index) {
if (iterator.call(context, value, index, this))
results.push(value);
}, this);
return results;}
function grep(filter, iterator, context) {
iterator = iterator || Prototype.K;
var results = [];
if (Object.isString(filter))
filter = new RegExp(RegExp.escape(filter));
this.each(function(value, index) {
if (filter.match(value))
results.push(iterator.call(context, value, index, this));
}, this);
return results;}
function include(object) {
if (Object.isFunction(this.indexOf))
if (this.indexOf(object) != -1) return true;
var found = false;
this.each(function(value) {
if (value == object) {
found = true;
throw $break;}});
return found;}
function inGroupsOf(number, fillWith) {
fillWith = Object.isUndefined(fillWith) ? null : fillWith;
return this.eachSlice(number, function(slice) {
while(slice.length < number) slice.push(fillWith);
return slice;});}
function inject(memo, iterator, context) {
this.each(function(value, index) {
memo = iterator.call(context, memo, value, index, this);
}, this);
return memo;}
function invoke(method) {
var args = $A(arguments).slice(1);
return this.map(function(value) {
return value[method].apply(value, args);});}
function max(iterator, context) {
iterator = iterator || Prototype.K;
var result;
this.each(function(value, index) {
value = iterator.call(context, value, index, this);
if (result == null || value >= result)
result = value;
}, this);
return result;}
function min(iterator, context) {
iterator = iterator || Prototype.K;
var result;
this.each(function(value, index) {
value = iterator.call(context, value, index, this);
if (result == null || value < result)
result = value;
}, this);
return result;}
function partition(iterator, context) {
iterator = iterator || Prototype.K;
var trues = [], falses = [];
this.each(function(value, index) {
(iterator.call(context, value, index, this) ?
trues : falses).push(value);
}, this);
return [trues, falses];}
function pluck(property) {
var results = [];
this.each(function(value) {
results.push(value[property]);});
return results;}
function reject(iterator, context) {
var results = [];
this.each(function(value, index) {
if (!iterator.call(context, value, index, this))
results.push(value);
}, this);
return results;}
function sortBy(iterator, context) {
return this.map(function(value, index) {
return {
value: value,
criteria: iterator.call(context, value, index, this)};
}, this).sort(function(left, right) {
var a = left.criteria, b = right.criteria;
return a < b ? -1 : a > b ? 1 : 0;
}).pluck('value');}
function toArray() {
return this.map();}
function zip() {
var iterator = Prototype.K, args = $A(arguments);
if (Object.isFunction(args.last()))
iterator = args.pop();
var collections = [this].concat(args).map($A);
return this.map(function(value, index) {
return iterator(collections.pluck(index));});}
function size() {
return this.toArray().length;}
function inspect() {
return '#<Enumerable:' + this.toArray().inspect() + '>';}
return {
each:       each,
eachSlice:  eachSlice,
all:        all,
every:      all,
any:        any,
some:       any,
collect:    collect,
map:        collect,
detect:     detect,
findAll:    findAll,
select:     findAll,
filter:     findAll,
grep:       grep,
include:    include,
member:     include,
inGroupsOf: inGroupsOf,
inject:     inject,
invoke:     invoke,
max:        max,
min:        min,
partition:  partition,
pluck:      pluck,
reject:     reject,
sortBy:     sortBy,
toArray:    toArray,
entries:    toArray,
zip:        zip,
size:       size,
inspect:    inspect,
find:       detect};
})();
function $A(iterable) {
if (!iterable) return [];
if ('toArray' in Object(iterable)) return iterable.toArray();
var length = iterable.length || 0, results = new Array(length);
while (length--) results[length] = iterable[length];
return results;}
function $w(string) {
if (!Object.isString(string)) return [];
string = string.strip();
return string ? string.split(/\s+/) : [];}
Array.from = $A;
(function() {
var arrayProto = Array.prototype,
slice = arrayProto.slice,
_each = arrayProto.forEach; // use native browser JS 1.6 implementation if available
function each(iterator, context) {
for (var i = 0, length = this.length >>> 0; i < length; i++) {
if (i in this) iterator.call(context, this[i], i, this);}}
if (!_each) _each = each;
function clear() {
this.length = 0;
return this;}
function first() {
return this[0];}
function last() {
return this[this.length - 1];}
function compact() {
return this.select(function(value) {
return value != null;});}
function flatten() {
return this.inject([], function(array, value) {
if (Object.isArray(value))
return array.concat(value.flatten());
array.push(value);
return array;});}
function without() {
var values = slice.call(arguments, 0);
return this.select(function(value) {
return !values.include(value);});}
function reverse(inline) {
return (inline === false ? this.toArray() : this)._reverse();}
function uniq(sorted) {
return this.inject([], function(array, value, index) {
if (0 == index || (sorted ? array.last() != value : !array.include(value)))
array.push(value);
return array;});}
function intersect(array) {
return this.uniq().findAll(function(item) {
return array.indexOf(item) !== -1;});}
function clone() {
return slice.call(this, 0);}
function size() {
return this.length;}
function inspect() {
return '[' + this.map(Object.inspect).join(', ') + ']';}
function indexOf(item, i) {
if (this == null) throw new TypeError();
var array = Object(this), length = array.length >>> 0;
if (length === 0) return -1;
i = Number(i);
if (isNaN(i)) {
i = 0;
} else if (i !== 0 && isFinite(i)) {
i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));}
if (i > length) return -1;
var k = i >= 0 ? i : Math.max(length - Math.abs(i), 0);
for (; k < length; k++)
if (k in array && array[k] === item) return k;
return -1;}
function lastIndexOf(item, i) {
if (this == null) throw new TypeError();
var array = Object(this), length = array.length >>> 0;
if (length === 0) return -1;
if (!Object.isUndefined(i)) {
i = Number(i);
if (isNaN(i)) {
i = 0;
} else if (i !== 0 && isFinite(i)) {
i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));}
} else {
i = length;}
var k = i >= 0 ? Math.min(i, length - 1) :
length - Math.abs(i);
for (; k >= 0; k--)
if (k in array && array[k] === item) return k;
return -1;}
function concat(_) {
var array = [], items = slice.call(arguments, 0), item, n = 0;
items.unshift(this);
for (var i = 0, length = items.length; i < length; i++) {
item = items[i];
if (Object.isArray(item) && !('callee' in item)) {
for (var j = 0, arrayLength = item.length; j < arrayLength; j++) {
if (j in item) array[n] = item[j];
n++;}
} else {
array[n++] = item;}}
array.length = n;
return array;}
function wrapNative(method) {
return function() {
if (arguments.length === 0) {
return method.call(this, Prototype.K);
} else if (arguments[0] === undefined) {
var args = slice.call(arguments, 1);
args.unshift(Prototype.K);
return method.apply(this, args);
} else {
return method.apply(this, arguments);}};}
function map(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var object = Object(this);
var results = [], context = arguments[1], n = 0;
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object) {
results[n] = iterator.call(context, object[i], i, object);}
n++;}
results.length = n;
return results;}
if (arrayProto.map) {
map = wrapNative(Array.prototype.map);}
function filter(iterator) {
if (this == null || !Object.isFunction(iterator))
throw new TypeError();
var object = Object(this);
var results = [], context = arguments[1], value;
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object) {
value = object[i];
if (iterator.call(context, value, i, object)) {
results.push(value);}}}
return results;}
if (arrayProto.filter) {
filter = Array.prototype.filter;}
function some(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var context = arguments[1];
var object = Object(this);
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object && iterator.call(context, object[i], i, object)) {
return true;}}
return false;}
if (arrayProto.some) {
var some = wrapNative(Array.prototype.some);}
function every(iterator) {
if (this == null) throw new TypeError();
iterator = iterator || Prototype.K;
var context = arguments[1];
var object = Object(this);
for (var i = 0, length = object.length >>> 0; i < length; i++) {
if (i in object && !iterator.call(context, object[i], i, object)) {
return false;}}
return true;}
if (arrayProto.every) {
var every = wrapNative(Array.prototype.every);}
var _reduce = arrayProto.reduce;
function inject(memo, iterator) {
iterator = iterator || Prototype.K;
var context = arguments[2];
return _reduce.call(this, iterator.bind(context), memo);}
if (!arrayProto.reduce) {
var inject = Enumerable.inject;}
Object.extend(arrayProto, Enumerable);
if (!arrayProto._reverse)
arrayProto._reverse = arrayProto.reverse;
Object.extend(arrayProto, {
_each:     _each,
map:       map,
collect:   map,
select:    filter,
filter:    filter,
findAll:   filter,
some:      some,
any:       some,
every:     every,
all:       every,
inject:    inject,
clear:     clear,
first:     first,
last:      last,
compact:   compact,
flatten:   flatten,
without:   without,
reverse:   reverse,
uniq:      uniq,
intersect: intersect,
clone:     clone,
toArray:   clone,
size:      size,
inspect:   inspect});
var CONCAT_ARGUMENTS_BUGGY = (function() {
return [].concat(arguments)[0][0] !== 1;
})(1,2);
if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;
if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
return new Hash(object);};
var Hash = Class.create(Enumerable, (function() {
function initialize(object) {
this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);}
function _each(iterator, context) {
var index = 0;
for (var key in this._object) {
var value = this._object[key], pair = [key, value];
pair.key = key;
pair.value = value;
iterator.call(context, pair, index++);}}
function set(key, value) {
return this._object[key] = value;}
function get(key) {
if (this._object[key] !== Object.prototype[key])
return this._object[key];}
function unset(key) {
var value = this._object[key];
delete this._object[key];
return value;}
function toObject() {
return Object.clone(this._object);}
function keys() {
return this.pluck('key');}
function values() {
return this.pluck('value');}
function index(value) {
var match = this.detect(function(pair) {
return pair.value === value;});
return match && match.key;}
function merge(object) {
return this.clone().update(object);}
function update(object) {
return new Hash(object).inject(this, function(result, pair) {
result.set(pair.key, pair.value);
return result;});}
function toQueryPair(key, value) {
if (Object.isUndefined(value)) return key;
var value = String.interpret(value);
value = value.gsub(/(\r)?\n/, '\r\n');
value = encodeURIComponent(value);
value = value.gsub(/%20/, '+');
return key + '=' + value;}
function toQueryString() {
return this.inject([], function(results, pair) {
var key = encodeURIComponent(pair.key), values = pair.value;
if (values && typeof values == 'object') {
if (Object.isArray(values)) {
var queryValues = [];
for (var i = 0, len = values.length, value; i < len; i++) {
value = values[i];
queryValues.push(toQueryPair(key, value));}
return results.concat(queryValues);}
} else results.push(toQueryPair(key, values));
return results;
}).join('&');}
function inspect() {
return '#<Hash:{' + this.map(function(pair) {
return pair.map(Object.inspect).join(': ');
}).join(', ') + '}>';}
function clone() {
return new Hash(this);}
return {
initialize:             initialize,
_each:                  _each,
set:                    set,
get:                    get,
unset:                  unset,
toObject:               toObject,
toTemplateReplacements: toObject,
keys:                   keys,
values:                 values,
index:                  index,
merge:                  merge,
update:                 update,
toQueryString:          toQueryString,
inspect:                inspect,
toJSON:                 toObject,
clone:                  clone};
})());
Hash.from = $H;
Object.extend(Number.prototype, (function() {
function toColorPart() {
return this.toPaddedString(2, 16);}
function succ() {
return this + 1;}
function times(iterator, context) {
$R(0, this, true).each(iterator, context);
return this;}
function toPaddedString(length, radix) {
var string = this.toString(radix || 10);
return '0'.times(length - string.length) + string;}
function abs() {
return Math.abs(this);}
function round() {
return Math.round(this);}
function ceil() {
return Math.ceil(this);}
function floor() {
return Math.floor(this);}
return {
toColorPart:    toColorPart,
succ:           succ,
times:          times,
toPaddedString: toPaddedString,
abs:            abs,
round:          round,
ceil:           ceil,
floor:          floor};
})());
function $R(start, end, exclusive) {
return new ObjectRange(start, end, exclusive);}
var ObjectRange = Class.create(Enumerable, (function() {
function initialize(start, end, exclusive) {
this.start = start;
this.end = end;
this.exclusive = exclusive;}
function _each(iterator, context) {
var value = this.start;
while (this.include(value)) {
iterator.call(context, value);
value = value.succ();}}
function include(value) {
if (value < this.start)
return false;
if (this.exclusive)
return value < this.end;
return value <= this.end;}
return {
initialize: initialize,
_each:      _each,
include:    include};
})());
var Abstract = { };
var Try = {
these: function() {
var returnValue;
for (var i = 0, length = arguments.length; i < length; i++) {
var lambda = arguments[i];
try {
returnValue = lambda();
break;
} catch (e) { }}
return returnValue;}};
var Ajax = {
getTransport: function() {
return Try.these(
function() {return new XMLHttpRequest()},
function() {return new ActiveXObject('Msxml2.XMLHTTP')},
function() {return new ActiveXObject('Microsoft.XMLHTTP')}
) || false;},
activeRequestCount: 0};
Ajax.Responders = {
responders: [],
_each: function(iterator, context) {
this.responders._each(iterator, context);},
register: function(responder) {
if (!this.include(responder))
this.responders.push(responder);},
unregister: function(responder) {
this.responders = this.responders.without(responder);},
dispatch: function(callback, request, transport, json) {
this.each(function(responder) {
if (Object.isFunction(responder[callback])) {
try {
responder[callback].apply(responder, [request, transport, json]);
} catch (e) { }}});}};
Object.extend(Ajax.Responders, Enumerable);
Ajax.Responders.register({
onCreate:   function() { Ajax.activeRequestCount++ },
onComplete: function() { Ajax.activeRequestCount-- }});
Ajax.Base = Class.create({
initialize: function(options) {
this.options = {
method:       'post',
asynchronous: true,
contentType:  'application/x-www-form-urlencoded',
encoding:     'UTF-8',
parameters:   '',
evalJSON:     true,
evalJS:       true};
Object.extend(this.options, options || { });
this.options.method = this.options.method.toLowerCase();
if (Object.isHash(this.options.parameters))
this.options.parameters = this.options.parameters.toObject();}});
Ajax.Request = Class.create(Ajax.Base, {
_complete: false,
initialize: function($super, url, options) {
$super(options);
this.transport = Ajax.getTransport();
this.request(url);},
request: function(url) {
this.url = url;
this.method = this.options.method;
var params = Object.isString(this.options.parameters) ?
this.options.parameters :
Object.toQueryString(this.options.parameters);
if (!['get', 'post'].include(this.method)) {
params += (params ? '&' : '') + "_method=" + this.method;
this.method = 'post';}
if (params && this.method === 'get') {
this.url += (this.url.include('?') ? '&' : '?') + params;}
this.parameters = params.toQueryParams();
try {
var response = new Ajax.Response(this);
if (this.options.onCreate) this.options.onCreate(response);
Ajax.Responders.dispatch('onCreate', this, response);
this.transport.open(this.method.toUpperCase(), this.url,
this.options.asynchronous);
if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);
this.transport.onreadystatechange = this.onStateChange.bind(this);
this.setRequestHeaders();
this.body = this.method == 'post' ? (this.options.postBody || params) : null;
this.transport.send(this.body);
if (!this.options.asynchronous && this.transport.overrideMimeType)
this.onStateChange();}
catch (e) {
this.dispatchException(e);}},
onStateChange: function() {
var readyState = this.transport.readyState;
if (readyState > 1 && !((readyState == 4) && this._complete))
this.respondToReadyState(this.transport.readyState);},
setRequestHeaders: function() {
var headers = {
'X-Requested-With': 'XMLHttpRequest',
'X-Prototype-Version': Prototype.Version,
'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'};
if (this.method == 'post') {
headers['Content-type'] = this.options.contentType +
(this.options.encoding ? '; charset=' + this.options.encoding : '');
if (this.transport.overrideMimeType &&
(navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
headers['Connection'] = 'close';}
if (typeof this.options.requestHeaders == 'object') {
var extras = this.options.requestHeaders;
if (Object.isFunction(extras.push))
for (var i = 0, length = extras.length; i < length; i += 2)
headers[extras[i]] = extras[i+1];
else
$H(extras).each(function(pair) { headers[pair.key] = pair.value });}
for (var name in headers)
this.transport.setRequestHeader(name, headers[name]);},
success: function() {
var status = this.getStatus();
return !status || (status >= 200 && status < 300) || status == 304;},
getStatus: function() {
try {
if (this.transport.status === 1223) return 204;
return this.transport.status || 0;
} catch (e) { return 0 }},
respondToReadyState: function(readyState) {
var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);
if (state == 'Complete') {
try {
this._complete = true;
(this.options['on' + response.status]
|| this.options['on' + (this.success() ? 'Success' : 'Failure')]
|| Prototype.emptyFunction)(response, response.headerJSON);
} catch (e) {
this.dispatchException(e);}
var contentType = response.getHeader('Content-type');
if (this.options.evalJS == 'force'
|| (this.options.evalJS && this.isSameOrigin() && contentType
&& contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
this.evalResponse();}
try {
(this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
} catch (e) {
this.dispatchException(e);}
if (state == 'Complete') {
this.transport.onreadystatechange = Prototype.emptyFunction;}},
isSameOrigin: function() {
var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
protocol: location.protocol,
domain: document.domain,
port: location.port ? ':' + location.port : ''
}));},
getHeader: function(name) {
try {
return this.transport.getResponseHeader(name) || null;
} catch (e) { return null; }},
evalResponse: function() {
try {
return eval((this.transport.responseText || '').unfilterJSON());
} catch (e) {
this.dispatchException(e);}},
dispatchException: function(exception) {
(this.options.onException || Prototype.emptyFunction)(this, exception);
Ajax.Responders.dispatch('onException', this, exception);}});
Ajax.Request.Events =
['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
Ajax.Response = Class.create({
initialize: function(request){
this.request = request;
var transport  = this.transport  = request.transport,
readyState = this.readyState = transport.readyState;
if ((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
this.status       = this.getStatus();
this.statusText   = this.getStatusText();
this.responseText = String.interpret(transport.responseText);
this.headerJSON   = this._getHeaderJSON();}
if (readyState == 4) {
var xml = transport.responseXML;
this.responseXML  = Object.isUndefined(xml) ? null : xml;
this.responseJSON = this._getResponseJSON();}},
status:      0,
statusText: '',
getStatus: Ajax.Request.prototype.getStatus,
getStatusText: function() {
try {
return this.transport.statusText || '';
} catch (e) { return '' }},
getHeader: Ajax.Request.prototype.getHeader,
getAllHeaders: function() {
try {
return this.getAllResponseHeaders();
} catch (e) { return null }},
getResponseHeader: function(name) {
return this.transport.getResponseHeader(name);},
getAllResponseHeaders: function() {
return this.transport.getAllResponseHeaders();},
_getHeaderJSON: function() {
var json = this.getHeader('X-JSON');
if (!json) return null;
try {
json = decodeURIComponent(escape(json));
} catch(e) {}
try {
return json.evalJSON(this.request.options.sanitizeJSON ||
!this.request.isSameOrigin());
} catch (e) {
this.request.dispatchException(e);}},
_getResponseJSON: function() {
var options = this.request.options;
if (!options.evalJSON || (options.evalJSON != 'force' &&
!(this.getHeader('Content-type') || '').include('application/json')) ||
this.responseText.blank())
return null;
try {
return this.responseText.evalJSON(options.sanitizeJSON ||
!this.request.isSameOrigin());
} catch (e) {
this.request.dispatchException(e);}}});
Ajax.Updater = Class.create(Ajax.Request, {
initialize: function($super, container, url, options) {
this.container = {
success: (container.success || container),
failure: (container.failure || (container.success ? null : container))};
options = Object.clone(options);
var onComplete = options.onComplete;
options.onComplete = (function(response, json) {
this.updateContent(response.responseText);
if (Object.isFunction(onComplete)) onComplete(response, json);
}).bind(this);
$super(url, options);},
updateContent: function(responseText) {
var receiver = this.container[this.success() ? 'success' : 'failure'],
options = this.options;
if (!options.evalScripts) responseText = responseText.stripScripts();
if (receiver = prototype$(receiver)) {
if (options.insertion) {
if (Object.isString(options.insertion)) {
var insertion = { }; insertion[options.insertion] = responseText;
receiver.insert(insertion);}
else options.insertion(receiver, responseText);}
else receiver.update(responseText);}}});
Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
initialize: function($super, container, url, options) {
$super(options);
this.onComplete = this.options.onComplete;
this.frequency = (this.options.frequency || 2);
this.decay = (this.options.decay || 1);
this.updater = { };
this.container = container;
this.url = url;
this.start();},
start: function() {
this.options.onComplete = this.updateComplete.bind(this);
this.onTimerEvent();},
stop: function() {
this.updater.options.onComplete = undefined;
clearTimeout(this.timer);
(this.onComplete || Prototype.emptyFunction).apply(this, arguments);},
updateComplete: function(response) {
if (this.options.decay) {
this.decay = (response.responseText == this.lastText ?
this.decay * this.options.decay : 1);
this.lastText = response.responseText;}
this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);},
onTimerEvent: function() {
this.updater = new Ajax.Updater(this.container, this.url, this.options);}});
(function(GLOBAL) {
var UNDEFINED;
var SLICE = Array.prototype.slice;
var DIV = document.createElement('div');
function prototype$(element) {
if (arguments.length > 1) {
for (var i = 0, elements = [], length = arguments.length; i < length; i++)
elements.push(prototype$(arguments[i]));
return elements;}
if (Object.isString(element))
element = document.getElementById(element);
return Element.extend(element);}
GLOBAL.prototype$ = prototype$;
if (!GLOBAL.Node) GLOBAL.Node = {};
if (!GLOBAL.Node.ELEMENT_NODE) {
Object.extend(GLOBAL.Node, {
ELEMENT_NODE:                1,
ATTRIBUTE_NODE:              2,
TEXT_NODE:                   3,
CDATA_SECTION_NODE:          4,
ENTITY_REFERENCE_NODE:       5,
ENTITY_NODE:                 6,
PROCESSING_INSTRUCTION_NODE: 7,
COMMENT_NODE:                8,
DOCUMENT_NODE:               9,
DOCUMENT_TYPE_NODE:         10,
DOCUMENT_FRAGMENT_NODE:     11,
NOTATION_NODE:              12});}
var ELEMENT_CACHE = {};
function shouldUseCreationCache(tagName, attributes) {
if (tagName === 'select') return false;
if ('type' in attributes) return false;
return true;}
var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function(){
try {
var el = document.createElement('<input name="x">');
return el.tagName.toLowerCase() === 'input' && el.name === 'x';}
catch(err) {
return false;}
})();
var oldElement = GLOBAL.Element;
function Element(tagName, attributes) {
attributes = attributes || {};
tagName = tagName.toLowerCase();
if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) {
tagName = '<' + tagName + ' name="' + attributes.name + '">';
delete attributes.name;
return Element.writeAttribute(document.createElement(tagName), attributes);}
if (!ELEMENT_CACHE[tagName])
ELEMENT_CACHE[tagName] = Element.extend(document.createElement(tagName));
var node = shouldUseCreationCache(tagName, attributes) ?
ELEMENT_CACHE[tagName].cloneNode(false) : document.createElement(tagName);
return Element.writeAttribute(node, attributes);}
GLOBAL.Element = Element;
Object.extend(GLOBAL.Element, oldElement || {});
if (oldElement) GLOBAL.Element.prototype = oldElement.prototype;
Element.Methods = { ByTag: {}, Simulated: {} };
var methods = {};
var INSPECT_ATTRIBUTES = { id: 'id', className: 'class' };
function inspect(element) {
element = prototype$(element);
var result = '<' + element.tagName.toLowerCase();
var attribute, value;
for (var property in INSPECT_ATTRIBUTES) {
attribute = INSPECT_ATTRIBUTES[property];
value = (element[property] || '').toString();
if (value) result += ' ' + attribute + '=' + value.inspect(true);}
return result + '>';}
methods.inspect = inspect;
function visible(element) {
return prototype$(element).style.display !== 'none';}
function toggle(element, bool) {
element = prototype$(element);
if (Object.isUndefined(bool))
bool = !Element.visible(element);
Element[bool ? 'show' : 'hide'](element);
return element;}
function hide(element) {
element = prototype$(element);
element.style.display = 'none';
return element;}
function show(element) {
element = prototype$(element);
element.style.display = '';
return element;}
Object.extend(methods, {
visible: visible,
toggle:  toggle,
hide:    hide,
show:    show});
function remove(element) {
element = prototype$(element);
element.parentNode.removeChild(element);
return element;}
var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
var el = document.createElement("select"),
isBuggy = true;
el.innerHTML = "<option value=\"test\">test</option>";
if (el.options && el.options[0]) {
isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";}
el = null;
return isBuggy;
})();
var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
try {
var el = document.createElement("table");
if (el && el.tBodies) {
el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
var isBuggy = typeof el.tBodies[0] == "undefined";
el = null;
return isBuggy;}
} catch (e) {
return true;}
})();
var LINK_ELEMENT_INNERHTML_BUGGY = (function() {
try {
var el = document.createElement('div');
el.innerHTML = "<link />";
var isBuggy = (el.childNodes.length === 0);
el = null;
return isBuggy;
} catch(e) {
return true;}
})();
var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;
var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
var s = document.createElement("script"),
isBuggy = false;
try {
s.appendChild(document.createTextNode(""));
isBuggy = !s.firstChild ||
s.firstChild && s.firstChild.nodeType !== 3;
} catch (e) {
isBuggy = true;}
s = null;
return isBuggy;
})();
function update(element, content) {
element = prototype$(element);
var descendants = element.getElementsByTagName('*'),
i = descendants.length;
while (i--) purgeElement(descendants[i]);
if (content && content.toElement)
content = content.toElement();
if (Object.isElement(content))
return element.update().insert(content);
content = Object.toHTML(content);
var tagName = element.tagName.toUpperCase();
if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
element.text = content;
return element;}
if (ANY_INNERHTML_BUGGY) {
if (tagName in INSERTION_TRANSLATIONS.tags) {
while (element.firstChild)
element.removeChild(element.firstChild);
var nodes = getContentFromAnonymousElement(tagName, content.stripScripts());
for (var i = 0, node; node = nodes[i]; i++)
element.appendChild(node);
} else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf('<link') > -1) {
while (element.firstChild)
element.removeChild(element.firstChild);
var nodes = getContentFromAnonymousElement(tagName,
content.stripScripts(), true);
for (var i = 0, node; node = nodes[i]; i++)
element.appendChild(node);
} else {
element.innerHTML = content.stripScripts();}
} else {
element.innerHTML = content.stripScripts();}
content.evalScripts.bind(content).defer();
return element;}
function replace(element, content) {
element = prototype$(element);
if (content && content.toElement) {
content = content.toElement();
} else if (!Object.isElement(content)) {
content = Object.toHTML(content);
var range = element.ownerDocument.createRange();
range.selectNode(element);
content.evalScripts.bind(content).defer();
content = range.createContextualFragment(content.stripScripts());}
element.parentNode.replaceChild(content, element);
return element;}
var INSERTION_TRANSLATIONS = {
before: function(element, node) {
element.parentNode.insertBefore(node, element);},
top: function(element, node) {
element.insertBefore(node, element.firstChild);},
bottom: function(element, node) {
element.appendChild(node);},
after: function(element, node) {
element.parentNode.insertBefore(node, element.nextSibling);},
tags: {
TABLE:  ['<table>',                '</table>',                   1],
TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
SELECT: ['<select>',               '</select>',                  1]}};
var tags = INSERTION_TRANSLATIONS.tags;
Object.extend(tags, {
THEAD: tags.TBODY,
TFOOT: tags.TBODY,
TH:    tags.TD});
function replace_IE(element, content) {
element = prototype$(element);
if (content && content.toElement)
content = content.toElement();
if (Object.isElement(content)) {
element.parentNode.replaceChild(content, element);
return element;}
content = Object.toHTML(content);
var parent = element.parentNode, tagName = parent.tagName.toUpperCase();
if (tagName in INSERTION_TRANSLATIONS.tags) {
var nextSibling = Element.next(element);
var fragments = getContentFromAnonymousElement(
tagName, content.stripScripts());
parent.removeChild(element);
var iterator;
if (nextSibling)
iterator = function(node) { parent.insertBefore(node, nextSibling) };
else
iterator = function(node) { parent.appendChild(node); }
fragments.each(iterator);
} else {
element.outerHTML = content.stripScripts();}
content.evalScripts.bind(content).defer();
return element;}
if ('outerHTML' in document.documentElement)
replace = replace_IE;
function isContent(content) {
if (Object.isUndefined(content) || content === null) return false;
if (Object.isString(content) || Object.isNumber(content)) return true;
if (Object.isElement(content)) return true;
if (content.toElement || content.toHTML) return true;
return false;}
function insertContentAt(element, content, position) {
position   = position.toLowerCase();
var method = INSERTION_TRANSLATIONS[position];
if (content && content.toElement) content = content.toElement();
if (Object.isElement(content)) {
method(element, content);
return element;}
content = Object.toHTML(content);
var tagName = ((position === 'before' || position === 'after') ?
element.parentNode : element).tagName.toUpperCase();
var childNodes = getContentFromAnonymousElement(tagName, content.stripScripts());
if (position === 'top' || position === 'after') childNodes.reverse();
for (var i = 0, node; node = childNodes[i]; i++)
method(element, node);
content.evalScripts.bind(content).defer();}
function insert(element, insertions) {
element = prototype$(element);
if (isContent(insertions))
insertions = { bottom: insertions };
for (var position in insertions)
insertContentAt(element, insertions[position], position);
return element;}
function wrap(element, wrapper, attributes) {
element = prototype$(element);
if (Object.isElement(wrapper)) {
prototype$(wrapper).writeAttribute(attributes || {});
} else if (Object.isString(wrapper)) {
wrapper = new Element(wrapper, attributes);
} else {
wrapper = new Element('div', wrapper);}
if (element.parentNode)
element.parentNode.replaceChild(wrapper, element);
wrapper.appendChild(element);
return wrapper;}
function cleanWhitespace(element) {
element = prototype$(element);
var node = element.firstChild;
while (node) {
var nextNode = node.nextSibling;
if (node.nodeType === Node.TEXT_NODE && !/\S/.test(node.nodeValue))
element.removeChild(node);
node = nextNode;}
return element;}
function empty(element) {
return prototype$(element).innerHTML.blank();}
function getContentFromAnonymousElement(tagName, html, force) {
var t = INSERTION_TRANSLATIONS.tags[tagName], div = DIV;
var workaround = !!t;
if (!workaround && force) {
workaround = true;
t = ['', '', 0];}
if (workaround) {
div.innerHTML = '&#160;' + t[0] + html + t[1];
div.removeChild(div.firstChild);
for (var i = t[2]; i--; )
div = div.firstChild;
} else {
div.innerHTML = html;}
return $A(div.childNodes);}
function clone(element, deep) {
if (!(element = prototype$(element))) return;
var clone = element.cloneNode(deep);
if (!HAS_UNIQUE_ID_PROPERTY) {
clone._prototypeUID = UNDEFINED;
if (deep) {
var descendants = Element.select(clone, '*'),
i = descendants.length;
while (i--)
descendants[i]._prototypeUID = UNDEFINED;}}
return Element.extend(clone);}
function purgeElement(element) {
var uid = getUniqueElementID(element);
if (uid) {
Element.stopObserving(element);
if (!HAS_UNIQUE_ID_PROPERTY)
element._prototypeUID = UNDEFINED;
delete Element.Storage[uid];}}
function purgeCollection(elements) {
var i = elements.length;
while (i--)
purgeElement(elements[i]);}
function purgeCollection_IE(elements) {
var i = elements.length, element, uid;
while (i--) {
element = elements[i];
uid = getUniqueElementID(element);
delete Element.Storage[uid];
delete Event.cache[uid];}}
if (HAS_UNIQUE_ID_PROPERTY) {
purgeCollection = purgeCollection_IE;}
function purge(element) {
if (!(element = prototype$(element))) return;
purgeElement(element);
var descendants = element.getElementsByTagName('*'),
i = descendants.length;
while (i--) purgeElement(descendants[i]);
return null;}
Object.extend(methods, {
remove:  remove,
update:  update,
replace: replace,
insert:  insert,
wrap:    wrap,
cleanWhitespace: cleanWhitespace,
empty:   empty,
clone:   clone,
purge:   purge});
function recursivelyCollect(element, property, maximumLength) {
element = prototype$(element);
maximumLength = maximumLength || -1;
var elements = [];
while (element = element[property]) {
if (element.nodeType === Node.ELEMENT_NODE)
elements.push(Element.extend(element));
if (elements.length === maximumLength) break;}
return elements;}
function ancestors(element) {
return recursivelyCollect(element, 'parentNode');}
function descendants(element) {
return Element.select(element, '*');}
function firstDescendant(element) {
element = prototype$(element).firstChild;
while (element && element.nodeType !== Node.ELEMENT_NODE)
element = element.nextSibling;
return prototype$(element);}
function immediateDescendants(element) {
var results = [], child = prototype$(element).firstChild;
while (child) {
if (child.nodeType === Node.ELEMENT_NODE)
results.push(Element.extend(child));
child = child.nextSibling;}
return results;}
function previousSiblings(element) {
return recursivelyCollect(element, 'previousSibling');}
function nextSiblings(element) {
return recursivelyCollect(element, 'nextSibling');}
function siblings(element) {
element = prototype$(element);
var previous = previousSiblings(element),
next = nextSiblings(element);
return previous.reverse().concat(next);}
function match(element, selector) {
element = prototype$(element);
if (Object.isString(selector))
return Prototype.Selector.match(element, selector);
return selector.match(element);}
function _recursivelyFind(element, property, expression, index) {
element = prototype$(element), expression = expression || 0, index = index || 0;
if (Object.isNumber(expression)) {
index = expression, expression = null;}
while (element = element[property]) {
if (element.nodeType !== 1) continue;
if (expression && !Prototype.Selector.match(element, expression))
continue;
if (--index >= 0) continue;
return Element.extend(element);}}
function up(element, expression, index) {
element = prototype$(element);
if (arguments.length === 1) return prototype$(element.parentNode);
return _recursivelyFind(element, 'parentNode', expression, index);}
function down(element, expression, index) {
element = prototype$(element), expression = expression || 0, index = index || 0;
if (Object.isNumber(expression))
index = expression, expression = '*';
var node = Prototype.Selector.select(expression, element)[index];
return Element.extend(node);}
function previous(element, expression, index) {
return _recursivelyFind(element, 'previousSibling', expression, index);}
function next(element, expression, index) {
return _recursivelyFind(element, 'nextSibling', expression, index);}
function select(element) {
element = prototype$(element);
var expressions = SLICE.call(arguments, 1).join(', ');
return Prototype.Selector.select(expressions, element);}
function adjacent(element) {
element = prototype$(element);
var expressions = SLICE.call(arguments, 1).join(', ');
var siblings = Element.siblings(element), results = [];
for (var i = 0, sibling; sibling = siblings[i]; i++) {
if (Prototype.Selector.match(sibling, expressions))
results.push(sibling);}
return results;}
function descendantOf_DOM(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
while (element = element.parentNode)
if (element === ancestor) return true;
return false;}
function descendantOf_contains(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
if (!ancestor.contains) return descendantOf_DOM(element, ancestor);
return ancestor.contains(element) && ancestor !== element;}
function descendantOf_compareDocumentPosition(element, ancestor) {
element = prototype$(element), ancestor = prototype$(ancestor);
return (element.compareDocumentPosition(ancestor) & 8) === 8;}
var descendantOf;
if (DIV.compareDocumentPosition) {
descendantOf = descendantOf_compareDocumentPosition;
} else if (DIV.contains) {
descendantOf = descendantOf_contains;
} else {
descendantOf = descendantOf_DOM;}
Object.extend(methods, {
recursivelyCollect:   recursivelyCollect,
ancestors:            ancestors,
descendants:          descendants,
firstDescendant:      firstDescendant,
immediateDescendants: immediateDescendants,
previousSiblings:     previousSiblings,
nextSiblings:         nextSiblings,
siblings:             siblings,
match:                match,
up:                   up,
down:                 down,
previous:             previous,
next:                 next,
select:               select,
adjacent:             adjacent,
descendantOf:         descendantOf,
getElementsBySelector: select,
childElements:         immediateDescendants});
var idCounter = 1;
function identify(element) {
element = prototype$(element);
var id = Element.readAttribute(element, 'id');
if (id) return id;
do { id = 'anonymous_element_' + idCounter++ } while (prototype$(id));
Element.writeAttribute(element, 'id', id);
return id;}
function readAttribute(element, name) {
return prototype$(element).getAttribute(name);}
function readAttribute_IE(element, name) {
element = prototype$(element);
var table = ATTRIBUTE_TRANSLATIONS.read;
if (table.values[name])
return table.values[name](element, name);
if (table.names[name]) name = table.names[name];
if (name.include(':')) {
if (!element.attributes || !element.attributes[name]) return null;
return element.attributes[name].value;}
return element.getAttribute(name);}
function readAttribute_Opera(element, name) {
if (name === 'title') return element.title;
return element.getAttribute(name);}
var PROBLEMATIC_ATTRIBUTE_READING = (function() {
DIV.setAttribute('onclick', []);
var value = DIV.getAttribute('onclick');
var isFunction = Object.isArray(value);
DIV.removeAttribute('onclick');
return isFunction;
})();
if (PROBLEMATIC_ATTRIBUTE_READING) {
readAttribute = readAttribute_IE;
} else if (Prototype.Browser.Opera) {
readAttribute = readAttribute_Opera;}
function writeAttribute(element, name, value) {
element = prototype$(element);
var attributes = {}, table = ATTRIBUTE_TRANSLATIONS.write;
if (typeof name === 'object') {
attributes = name;
} else {
attributes[name] = Object.isUndefined(value) ? true : value;}
for (var attr in attributes) {
name = table.names[attr] || attr;
value = attributes[attr];
if (table.values[attr])
name = table.values[attr](element, value);
if (value === false || value === null)
element.removeAttribute(name);
else if (value === true)
element.setAttribute(name, name);
else element.setAttribute(name, value);}
return element;}
function hasAttribute(element, attribute) {
attribute = ATTRIBUTE_TRANSLATIONS.has[attribute] || attribute;
var node = prototype$(element).getAttributeNode(attribute);
return !!(node && node.specified);}
GLOBAL.Element.Methods.Simulated.hasAttribute = hasAttribute;
function classNames(element) {
return new Element.ClassNames(element);}
var regExpCache = {};
function getRegExpForClassName(className) {
if (regExpCache[className]) return regExpCache[className];
var re = new RegExp("(^|\\s+)" + className + "(\\s+|$)");
regExpCache[className] = re;
return re;}
function hasClassName(element, className) {
if (!(element = prototype$(element))) return;
var elementClassName = element.className;
if (elementClassName.length === 0) return false;
if (elementClassName === className) return true;
return getRegExpForClassName(className).test(elementClassName);}
function addClassName(element, className) {
if (!(element = prototype$(element))) return;
if (!hasClassName(element, className))
element.className += (element.className ? ' ' : '') + className;
return element;}
function removeClassName(element, className) {
if (!(element = prototype$(element))) return;
element.className = element.className.replace(
getRegExpForClassName(className), ' ').strip();
return element;}
function toggleClassName(element, className, bool) {
if (!(element = prototype$(element))) return;
if (Object.isUndefined(bool))
bool = !hasClassName(element, className);
var method = Element[bool ? 'addClassName' : 'removeClassName'];
return method(element, className);}
var ATTRIBUTE_TRANSLATIONS = {};
var classProp = 'className', forProp = 'for';
DIV.setAttribute(classProp, 'x');
if (DIV.className !== 'x') {
DIV.setAttribute('class', 'x');
if (DIV.className === 'x')
classProp = 'class';}
var LABEL = document.createElement('label');
LABEL.setAttribute(forProp, 'x');
if (LABEL.htmlFor !== 'x') {
LABEL.setAttribute('htmlFor', 'x');
if (LABEL.htmlFor === 'x')
forProp = 'htmlFor';}
LABEL = null;
function _getAttr(element, attribute) {
return element.getAttribute(attribute);}
function _getAttr2(element, attribute) {
return element.getAttribute(attribute, 2);}
function _getAttrNode(element, attribute) {
var node = element.getAttributeNode(attribute);
return node ? node.value : '';}
function _getFlag(element, attribute) {
return prototype$(element).hasAttribute(attribute) ? attribute : null;}
DIV.onclick = Prototype.emptyFunction;
var onclickValue = DIV.getAttribute('onclick');
var _getEv;
if (String(onclickValue).indexOf('{') > -1) {
_getEv = function(element, attribute) {
var value = element.getAttribute(attribute);
if (!value) return null;
value = value.toString();
value = value.split('{')[1];
value = value.split('}')[0];
return value.strip();};}
else if (onclickValue === '') {
_getEv = function(element, attribute) {
var value = element.getAttribute(attribute);
if (!value) return null;
return value.strip();};}
ATTRIBUTE_TRANSLATIONS.read = {
names: {
'class':     classProp,
'className': classProp,
'for':       forProp,
'htmlFor':   forProp},
values: {
style: function(element) {
return element.style.cssText.toLowerCase();},
title: function(element) {
return element.title;}}};
ATTRIBUTE_TRANSLATIONS.write = {
names: {
className:   'class',
htmlFor:     'for',
cellpadding: 'cellPadding',
cellspacing: 'cellSpacing'},
values: {
checked: function(element, value) {
element.checked = !!value;},
style: function(element, value) {
element.style.cssText = value ? value : '';}}};
ATTRIBUTE_TRANSLATIONS.has = { names: {} };
Object.extend(ATTRIBUTE_TRANSLATIONS.write.names,
ATTRIBUTE_TRANSLATIONS.read.names);
var CAMEL_CASED_ATTRIBUTE_NAMES = $w('colSpan rowSpan vAlign dateTime ' +
'accessKey tabIndex encType maxLength readOnly longDesc frameBorder');
for (var i = 0, attr; attr = CAMEL_CASED_ATTRIBUTE_NAMES[i]; i++) {
ATTRIBUTE_TRANSLATIONS.write.names[attr.toLowerCase()] = attr;
ATTRIBUTE_TRANSLATIONS.has.names[attr.toLowerCase()]   = attr;}
Object.extend(ATTRIBUTE_TRANSLATIONS.read.values, {
href:        _getAttr2,
src:         _getAttr2,
type:        _getAttr,
action:      _getAttrNode,
disabled:    _getFlag,
checked:     _getFlag,
readonly:    _getFlag,
multiple:    _getFlag,
onload:      _getEv,
onunload:    _getEv,
onclick:     _getEv,
ondblclick:  _getEv,
onmousedown: _getEv,
onmouseup:   _getEv,
onmouseover: _getEv,
onmousemove: _getEv,
onmouseout:  _getEv,
onfocus:     _getEv,
onblur:      _getEv,
onkeypress:  _getEv,
onkeydown:   _getEv,
onkeyup:     _getEv,
onsubmit:    _getEv,
onreset:     _getEv,
onselect:    _getEv,
onchange:    _getEv});
Object.extend(methods, {
identify:        identify,
readAttribute:   readAttribute,
writeAttribute:  writeAttribute,
classNames:      classNames,
hasClassName:    hasClassName,
addClassName:    addClassName,
removeClassName: removeClassName,
toggleClassName: toggleClassName});
function normalizeStyleName(style) {
if (style === 'float' || style === 'styleFloat')
return 'cssFloat';
return style.camelize();}
function normalizeStyleName_IE(style) {
if (style === 'float' || style === 'cssFloat')
return 'styleFloat';
return style.camelize();}
function setStyle(element, styles) {
element = prototype$(element);
var elementStyle = element.style, match;
if (Object.isString(styles)) {
elementStyle.cssText += ';' + styles;
if (styles.include('opacity')) {
var opacity = styles.match(/opacity:\s*(\d?\.?\d*)/)[1];
Element.setOpacity(element, opacity);}
return element;}
for (var property in styles) {
if (property === 'opacity') {
Element.setOpacity(element, styles[property]);
} else {
var value = styles[property];
if (property === 'float' || property === 'cssFloat') {
property = Object.isUndefined(elementStyle.styleFloat) ?
'cssFloat' : 'styleFloat';}
elementStyle[property] = value;}}
return element;}
function getStyle(element, style) {
element = prototype$(element);
style = normalizeStyleName(style);
var value = element.style[style];
if (!value || value === 'auto') {
var css = document.defaultView.getComputedStyle(element, null);
value = css ? css[style] : null;}
if (style === 'opacity') return value ? parseFloat(value) : 1.0;
return value === 'auto' ? null : value;}
function getStyle_Opera(element, style) {
switch (style) {
case 'height': case 'width':
if (!Element.visible(element)) return null;
var dim = parseInt(getStyle(element, style), 10);
if (dim !== element['offset' + style.capitalize()])
return dim + 'px';
return Element.measure(element, style);
default: return getStyle(element, style);}}
function getStyle_IE(element, style) {
element = prototype$(element);
style = normalizeStyleName_IE(style);
var value = element.style[style];
if (!value && element.currentStyle) {
value = element.currentStyle[style];}
if (style === 'opacity' && !STANDARD_CSS_OPACITY_SUPPORTED)
return getOpacity_IE(element);
if (value === 'auto') {
if ((style === 'width' || style === 'height') && Element.visible(element))
return Element.measure(element, style) + 'px';
return null;}
return value;}
function stripAlphaFromFilter_IE(filter) {
return (filter || '').replace(/alpha\([^\)]*\)/gi, '');}
function hasLayout_IE(element) {
if (!element.currentStyle.hasLayout)
element.style.zoom = 1;
return element;}
var STANDARD_CSS_OPACITY_SUPPORTED = (function() {
DIV.style.cssText = "opacity:.55";
return /^0.55/.test(DIV.style.opacity);
})();
function setOpacity(element, value) {
element = prototype$(element);
if (value == 1 || value === '') value = '';
else if (value < 0.00001) value = 0;
element.style.opacity = value;
return element;}
function setOpacity_IE(element, value) {
if (STANDARD_CSS_OPACITY_SUPPORTED)
return setOpacity(element, value);
element = hasLayout_IE(prototype$(element));
var filter = Element.getStyle(element, 'filter'),
style = element.style;
if (value == 1 || value === '') {
filter = stripAlphaFromFilter_IE(filter);
if (filter) style.filter = filter;
else style.removeAttribute('filter');
return element;}
if (value < 0.00001) value = 0;
style.filter = stripAlphaFromFilter_IE(filter) +
'alpha(opacity=' + (value * 100) + ')';
return element;}
function getOpacity(element) {
return Element.getStyle(element, 'opacity');}
function getOpacity_IE(element) {
if (STANDARD_CSS_OPACITY_SUPPORTED)
return getOpacity(element);
var filter = Element.getStyle(element, 'filter');
if (filter.length === 0) return 1.0;
var match = (filter || '').match(/alpha\(opacity=(.*)\)/);
if (match[1]) return parseFloat(match[1]) / 100;
return 1.0;}
Object.extend(methods, {
setStyle:   setStyle,
getStyle:   getStyle,
setOpacity: setOpacity,
getOpacity: getOpacity});
if ('styleFloat' in DIV.style) {
methods.getStyle = getStyle_IE;
methods.setOpacity = setOpacity_IE;
methods.getOpacity = getOpacity_IE;}
var UID = 0;
GLOBAL.Element.Storage = { UID: 1 };
function getUniqueElementID(element) {
if (element === window) return 0;
if (typeof element._prototypeUID === 'undefined')
element._prototypeUID = Element.Storage.UID++;
return element._prototypeUID;}
function getUniqueElementID_IE(element) {
if (element === window) return 0;
if (element == document) return 1;
return element.uniqueID;}
var HAS_UNIQUE_ID_PROPERTY = ('uniqueID' in DIV);
if (HAS_UNIQUE_ID_PROPERTY)
getUniqueElementID = getUniqueElementID_IE;
function getStorage(element) {
if (!(element = prototype$(element))) return;
var uid = getUniqueElementID(element);
if (!Element.Storage[uid])
Element.Storage[uid] = $H();
return Element.Storage[uid];}
function store(element, key, value) {
if (!(element = prototype$(element))) return;
var storage = getStorage(element);
if (arguments.length === 2) {
storage.update(key);
} else {
storage.set(key, value);}
return element;}
function retrieve(element, key, defaultValue) {
if (!(element = prototype$(element))) return;
var storage = getStorage(element), value = storage.get(key);
if (Object.isUndefined(value)) {
storage.set(key, defaultValue);
value = defaultValue;}
return value;}
Object.extend(methods, {
getStorage: getStorage,
store:      store,
retrieve:   retrieve});
var Methods = {}, ByTag = Element.Methods.ByTag,
F = Prototype.BrowserFeatures;
if (!F.ElementExtensions && ('__proto__' in DIV)) {
GLOBAL.HTMLElement = {};
GLOBAL.HTMLElement.prototype = DIV['__proto__'];
F.ElementExtensions = true;}
function checkElementPrototypeDeficiency(tagName) {
if (typeof window.Element === 'undefined') return false;
var proto = window.Element.prototype;
if (proto) {
var id = '_' + (Math.random() + '').slice(2),
el = document.createElement(tagName);
proto[id] = 'x';
var isBuggy = (el[id] !== 'x');
delete proto[id];
el = null;
return isBuggy;}
return false;}
var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY =
checkElementPrototypeDeficiency('object');
function extendElementWith(element, methods) {
for (var property in methods) {
var value = methods[property];
if (Object.isFunction(value) && !(property in element))
element[property] = value.methodize();}}
var EXTENDED = {};
function elementIsExtended(element) {
var uid = getUniqueElementID(element);
return (uid in EXTENDED);}
function extend(element) {
if (!element || elementIsExtended(element)) return element;
if (element.nodeType !== Node.ELEMENT_NODE || element == window)
return element;
var methods = Object.clone(Methods),
tagName = element.tagName.toUpperCase();
if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);
extendElementWith(element, methods);
EXTENDED[getUniqueElementID(element)] = true;
return element;}
function extend_IE8(element) {
if (!element || elementIsExtended(element)) return element;
var t = element.tagName;
if (t && (/^(?:object|applet|embed)$/i.test(t))) {
extendElementWith(element, Element.Methods);
extendElementWith(element, Element.Methods.Simulated);
extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);}
return element;}
if (F.SpecificElementExtensions) {
extend = HTMLOBJECTELEMENT_PROTOTYPE_BUGGY ? extend_IE8 : Prototype.K;}
function addMethodsToTagName(tagName, methods) {
tagName = tagName.toUpperCase();
if (!ByTag[tagName]) ByTag[tagName] = {};
Object.extend(ByTag[tagName], methods);}
function mergeMethods(destination, methods, onlyIfAbsent) {
if (Object.isUndefined(onlyIfAbsent)) onlyIfAbsent = false;
for (var property in methods) {
var value = methods[property];
if (!Object.isFunction(value)) continue;
if (!onlyIfAbsent || !(property in destination))
destination[property] = value.methodize();}}
function findDOMClass(tagName) {
var klass;
var trans = {
"OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
"FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
"DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
"H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
"INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
"TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
"TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
"TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
"FrameSet", "IFRAME": "IFrame"};
if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
if (window[klass]) return window[klass];
klass = 'HTML' + tagName + 'Element';
if (window[klass]) return window[klass];
klass = 'HTML' + tagName.capitalize() + 'Element';
if (window[klass]) return window[klass];
var element = document.createElement(tagName),
proto = element['__proto__'] || element.constructor.prototype;
element = null;
return proto;}
function addMethods(methods) {
if (arguments.length === 0) addFormMethods();
if (arguments.length === 2) {
var tagName = methods;
methods = arguments[1];}
if (!tagName) {
Object.extend(Element.Methods, methods || {});
} else {
if (Object.isArray(tagName)) {
for (var i = 0, tag; tag = tagName[i]; i++)
addMethodsToTagName(tag, methods);
} else {
addMethodsToTagName(tagName, methods);}}
var ELEMENT_PROTOTYPE = window.HTMLElement ? HTMLElement.prototype :
Element.prototype;
if (F.ElementExtensions) {
mergeMethods(ELEMENT_PROTOTYPE, Element.Methods);
mergeMethods(ELEMENT_PROTOTYPE, Element.Methods.Simulated, true);}
if (F.SpecificElementExtensions) {
for (var tag in Element.Methods.ByTag) {
var klass = findDOMClass(tag);
if (Object.isUndefined(klass)) continue;
mergeMethods(klass.prototype, ByTag[tag]);}}
Object.extend(Element, Element.Methods);
Object.extend(Element, Element.Methods.Simulated);
delete Element.ByTag;
delete Element.Simulated;
Element.extend.refresh();
ELEMENT_CACHE = {};}
Object.extend(GLOBAL.Element, {
extend:     extend,
addMethods: addMethods});
if (extend === Prototype.K) {
GLOBAL.Element.extend.refresh = Prototype.emptyFunction;
} else {
GLOBAL.Element.extend.refresh = function() {
if (Prototype.BrowserFeatures.ElementExtensions) return;
Object.extend(Methods, Element.Methods);
Object.extend(Methods, Element.Methods.Simulated);
EXTENDED = {};};}
function addFormMethods() {
Object.extend(Form, Form.Methods);
Object.extend(Form.Element, Form.Element.Methods);
Object.extend(Element.Methods.ByTag, {
"FORM":     Object.clone(Form.Methods),
"INPUT":    Object.clone(Form.Element.Methods),
"SELECT":   Object.clone(Form.Element.Methods),
"TEXTAREA": Object.clone(Form.Element.Methods),
"BUTTON":   Object.clone(Form.Element.Methods)});}
Element.addMethods(methods);
})(this);
(function() {
function toDecimal(pctString) {
var match = pctString.match(/^(\d+)%?$/i);
if (!match) return null;
return (Number(match[1]) / 100);}
function getRawStyle(element, style) {
element = prototype$(element);
var value = element.style[style];
if (!value || value === 'auto') {
var css = document.defaultView.getComputedStyle(element, null);
value = css ? css[style] : null;}
if (style === 'opacity') return value ? parseFloat(value) : 1.0;
return value === 'auto' ? null : value;}
function getRawStyle_IE(element, style) {
var value = element.style[style];
if (!value && element.currentStyle) {
value = element.currentStyle[style];}
return value;}
function getContentWidth(element, context) {
var boxWidth = element.offsetWidth;
var bl = getPixelValue(element, 'borderLeftWidth',  context) || 0;
var br = getPixelValue(element, 'borderRightWidth', context) || 0;
var pl = getPixelValue(element, 'paddingLeft',      context) || 0;
var pr = getPixelValue(element, 'paddingRight',     context) || 0;
return boxWidth - bl - br - pl - pr;}
if ('currentStyle' in document.documentElement) {
getRawStyle = getRawStyle_IE;}
function getPixelValue(value, property, context) {
var element = null;
if (Object.isElement(value)) {
element = value;
value = getRawStyle(element, property);}
if (value === null || Object.isUndefined(value)) {
return null;}
if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
return window.parseFloat(value);}
var isPercentage = value.include('%'), isViewport = (context === document.viewport);
if (/\d/.test(value) && element && element.runtimeStyle && !(isPercentage && isViewport)) {
var style = element.style.left, rStyle = element.runtimeStyle.left;
element.runtimeStyle.left = element.currentStyle.left;
element.style.left = value || 0;
value = element.style.pixelLeft;
element.style.left = style;
element.runtimeStyle.left = rStyle;
return value;}
if (element && isPercentage) {
context = context || element.parentNode;
var decimal = toDecimal(value), whole = null;
var isHorizontal = property.include('left') || property.include('right') ||
property.include('width');
var isVertical   = property.include('top') || property.include('bottom') ||
property.include('height');
if (context === document.viewport) {
if (isHorizontal) {
whole = document.viewport.getWidth();
} else if (isVertical) {
whole = document.viewport.getHeight();}
} else {
if (isHorizontal) {
whole = prototype$(context).measure('width');
} else if (isVertical) {
whole = prototype$(context).measure('height');}}
return (whole === null) ? 0 : whole * decimal;}
return 0;}
function toCSSPixels(number) {
if (Object.isString(number) && number.endsWith('px'))
return number;
return number + 'px';}
function isDisplayed(element) {
while (element && element.parentNode) {
var display = element.getStyle('display');
if (display === 'none') {
return false;}
element = prototype$(element.parentNode);}
return true;}
var hasLayout = Prototype.K;
if ('currentStyle' in document.documentElement) {
hasLayout = function(element) {
if (!element.currentStyle.hasLayout) {
element.style.zoom = 1;}
return element;};}
function cssNameFor(key) {
if (key.include('border')) key = key + '-width';
return key.camelize();}
Element.Layout = Class.create(Hash, {
initialize: function($super, element, preCompute) {
$super();
this.element = prototype$(element);
Element.Layout.PROPERTIES.each( function(property) {
this._set(property, null);
}, this);
if (preCompute) {
this._preComputing = true;
this._begin();
Element.Layout.PROPERTIES.each( this._compute, this );
this._end();
this._preComputing = false;}},
_set: function(property, value) {
return Hash.prototype.set.call(this, property, value);},
set: function(property, value) {
throw "Properties of Element.Layout are read-only.";},
get: function($super, property) {
var value = $super(property);
return value === null ? this._compute(property) : value;},
_begin: function() {
if (this._isPrepared()) return;
var element = this.element;
if (isDisplayed(element)) {
this._setPrepared(true);
return;}
var originalStyles = {
position:   element.style.position   || '',
width:      element.style.width      || '',
visibility: element.style.visibility || '',
display:    element.style.display    || ''};
element.store('prototype_original_styles', originalStyles);
var position = getRawStyle(element, 'position'), width = element.offsetWidth;
if (width === 0 || width === null) {
element.style.display = 'block';
width = element.offsetWidth;}
var context = (position === 'fixed') ? document.viewport :
element.parentNode;
var tempStyles = {
visibility: 'hidden',
display:    'block'};
if (position !== 'fixed') tempStyles.position = 'absolute';
element.setStyle(tempStyles);
var positionedWidth = element.offsetWidth, newWidth;
if (width && (positionedWidth === width)) {
newWidth = getContentWidth(element, context);
} else if (position === 'absolute' || position === 'fixed') {
newWidth = getContentWidth(element, context);
} else {
var parent = element.parentNode, pLayout = prototype$(parent).getLayout();
newWidth = pLayout.get('width') -
this.get('margin-left') -
this.get('border-left') -
this.get('padding-left') -
this.get('padding-right') -
this.get('border-right') -
this.get('margin-right');}
element.setStyle({ width: newWidth + 'px' });
this._setPrepared(true);},
_end: function() {
var element = this.element;
var originalStyles = element.retrieve('prototype_original_styles');
element.store('prototype_original_styles', null);
element.setStyle(originalStyles);
this._setPrepared(false);},
_compute: function(property) {
var COMPUTATIONS = Element.Layout.COMPUTATIONS;
if (!(property in COMPUTATIONS)) {
throw "Property not found.";}
return this._set(property, COMPUTATIONS[property].call(this, this.element));},
_isPrepared: function() {
return this.element.retrieve('prototype_element_layout_prepared', false);},
_setPrepared: function(bool) {
return this.element.store('prototype_element_layout_prepared', bool);},
toObject: function() {
var args = $A(arguments);
var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
args.join(' ').split(' ');
var obj = {};
keys.each( function(key) {
if (!Element.Layout.PROPERTIES.include(key)) return;
var value = this.get(key);
if (value != null) obj[key] = value;
}, this);
return obj;},
toHash: function() {
var obj = this.toObject.apply(this, arguments);
return new Hash(obj);},
toCSS: function() {
var args = $A(arguments);
var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
args.join(' ').split(' ');
var css = {};
keys.each( function(key) {
if (!Element.Layout.PROPERTIES.include(key)) return;
if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;
var value = this.get(key);
if (value != null) css[cssNameFor(key)] = value + 'px';
}, this);
return css;},
inspect: function() {
return "#<Element.Layout>";}});
Object.extend(Element.Layout, {
PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),
COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),
COMPUTATIONS: {
'height': function(element) {
if (!this._preComputing) this._begin();
var bHeight = this.get('border-box-height');
if (bHeight <= 0) {
if (!this._preComputing) this._end();
return 0;}
var bTop = this.get('border-top'),
bBottom = this.get('border-bottom');
var pTop = this.get('padding-top'),
pBottom = this.get('padding-bottom');
if (!this._preComputing) this._end();
return bHeight - bTop - bBottom - pTop - pBottom;},
'width': function(element) {
if (!this._preComputing) this._begin();
var bWidth = this.get('border-box-width');
if (bWidth <= 0) {
if (!this._preComputing) this._end();
return 0;}
var bLeft = this.get('border-left'),
bRight = this.get('border-right');
var pLeft = this.get('padding-left'),
pRight = this.get('padding-right');
if (!this._preComputing) this._end();
return bWidth - bLeft - bRight - pLeft - pRight;},
'padding-box-height': function(element) {
var height = this.get('height'),
pTop = this.get('padding-top'),
pBottom = this.get('padding-bottom');
return height + pTop + pBottom;},
'padding-box-width': function(element) {
var width = this.get('width'),
pLeft = this.get('padding-left'),
pRight = this.get('padding-right');
return width + pLeft + pRight;},
'border-box-height': function(element) {
if (!this._preComputing) this._begin();
var height = element.offsetHeight;
if (!this._preComputing) this._end();
return height;},
'border-box-width': function(element) {
if (!this._preComputing) this._begin();
var width = element.offsetWidth;
if (!this._preComputing) this._end();
return width;},
'margin-box-height': function(element) {
var bHeight = this.get('border-box-height'),
mTop = this.get('margin-top'),
mBottom = this.get('margin-bottom');
if (bHeight <= 0) return 0;
return bHeight + mTop + mBottom;},
'margin-box-width': function(element) {
var bWidth = this.get('border-box-width'),
mLeft = this.get('margin-left'),
mRight = this.get('margin-right');
if (bWidth <= 0) return 0;
return bWidth + mLeft + mRight;},
'top': function(element) {
var offset = element.positionedOffset();
return offset.top;},
'bottom': function(element) {
var offset = element.positionedOffset(),
parent = element.getOffsetParent(),
pHeight = parent.measure('height');
var mHeight = this.get('border-box-height');
return pHeight - mHeight - offset.top;},
'left': function(element) {
var offset = element.positionedOffset();
return offset.left;},
'right': function(element) {
var offset = element.positionedOffset(),
parent = element.getOffsetParent(),
pWidth = parent.measure('width');
var mWidth = this.get('border-box-width');
return pWidth - mWidth - offset.left;},
'padding-top': function(element) {
return getPixelValue(element, 'paddingTop');},
'padding-bottom': function(element) {
return getPixelValue(element, 'paddingBottom');},
'padding-left': function(element) {
return getPixelValue(element, 'paddingLeft');},
'padding-right': function(element) {
return getPixelValue(element, 'paddingRight');},
'border-top': function(element) {
return getPixelValue(element, 'borderTopWidth');},
'border-bottom': function(element) {
return getPixelValue(element, 'borderBottomWidth');},
'border-left': function(element) {
return getPixelValue(element, 'borderLeftWidth');},
'border-right': function(element) {
return getPixelValue(element, 'borderRightWidth');},
'margin-top': function(element) {
return getPixelValue(element, 'marginTop');},
'margin-bottom': function(element) {
return getPixelValue(element, 'marginBottom');},
'margin-left': function(element) {
return getPixelValue(element, 'marginLeft');},
'margin-right': function(element) {
return getPixelValue(element, 'marginRight');}}});
if ('getBoundingClientRect' in document.documentElement) {
Object.extend(Element.Layout.COMPUTATIONS, {
'right': function(element) {
var parent = hasLayout(element.getOffsetParent());
var rect = element.getBoundingClientRect(),
pRect = parent.getBoundingClientRect();
return (pRect.right - rect.right).round();},
'bottom': function(element) {
var parent = hasLayout(element.getOffsetParent());
var rect = element.getBoundingClientRect(),
pRect = parent.getBoundingClientRect();
return (pRect.bottom - rect.bottom).round();}});}
Element.Offset = Class.create({
initialize: function(left, top) {
this.left = left.round();
this.top  = top.round();
this[0] = this.left;
this[1] = this.top;},
relativeTo: function(offset) {
return new Element.Offset(
this.left - offset.left,
this.top  - offset.top
);},
inspect: function() {
return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this);},
toString: function() {
return "[#{left}, #{top}]".interpolate(this);},
toArray: function() {
return [this.left, this.top];}});
function getLayout(element, preCompute) {
return new Element.Layout(element, preCompute);}
function measure(element, property) {
return prototype$(element).getLayout().get(property);}
function getHeight(element) {
return Element.getDimensions(element).height;}
function getWidth(element) {
return Element.getDimensions(element).width;}
function getDimensions(element) {
element = prototype$(element);
var display = Element.getStyle(element, 'display');
if (display && display !== 'none') {
return { width: element.offsetWidth, height: element.offsetHeight };}
var style = element.style;
var originalStyles = {
visibility: style.visibility,
position:   style.position,
display:    style.display};
var newStyles = {
visibility: 'hidden',
display:    'block'};
if (originalStyles.position !== 'fixed')
newStyles.position = 'absolute';
Element.setStyle(element, newStyles);
var dimensions = {
width:  element.offsetWidth,
height: element.offsetHeight};
Element.setStyle(element, originalStyles);
return dimensions;}
function getOffsetParent(element) {
element = prototype$(element);
if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
return prototype$(document.body);
var isInline = (Element.getStyle(element, 'display') === 'inline');
if (!isInline && element.offsetParent) return prototype$(element.offsetParent);
while ((element = element.parentNode) && element !== document.body) {
if (Element.getStyle(element, 'position') !== 'static') {
return isHtml(element) ? prototype$(document.body) : prototype$(element);}}
return prototype$(document.body);}
function cumulativeOffset(element) {
element = prototype$(element);
var valueT = 0, valueL = 0;
if (element.parentNode) {
do {
valueT += element.offsetTop  || 0;
valueL += element.offsetLeft || 0;
element = element.offsetParent;
} while (element);}
return new Element.Offset(valueL, valueT);}
function positionedOffset(element) {
element = prototype$(element);
var layout = element.getLayout();
var valueT = 0, valueL = 0;
do {
valueT += element.offsetTop  || 0;
valueL += element.offsetLeft || 0;
element = element.offsetParent;
if (element) {
if (isBody(element)) break;
var p = Element.getStyle(element, 'position');
if (p !== 'static') break;}
} while (element);
valueL -= layout.get('margin-top');
valueT -= layout.get('margin-left');
return new Element.Offset(valueL, valueT);}
function cumulativeScrollOffset(element) {
var valueT = 0, valueL = 0;
do {
valueT += element.scrollTop  || 0;
valueL += element.scrollLeft || 0;
element = element.parentNode;
} while (element);
return new Element.Offset(valueL, valueT);}
function viewportOffset(forElement) {
var valueT = 0, valueL = 0, docBody = document.body;
var element = prototype$(forElement);
do {
valueT += element.offsetTop  || 0;
valueL += element.offsetLeft || 0;
if (element.offsetParent == docBody &&
Element.getStyle(element, 'position') == 'absolute') break;
} while (element = element.offsetParent);
element = forElement;
do {
if (element != docBody) {
valueT -= element.scrollTop  || 0;
valueL -= element.scrollLeft || 0;}
} while (element = element.parentNode);
return new Element.Offset(valueL, valueT);}
function absolutize(element) {
element = prototype$(element);
if (Element.getStyle(element, 'position') === 'absolute') {
return element;}
var offsetParent = getOffsetParent(element);
var eOffset = element.viewportOffset(),
pOffset = offsetParent.viewportOffset();
var offset = eOffset.relativeTo(pOffset);
var layout = element.getLayout();
element.store('prototype_absolutize_original_styles', {
left:   element.getStyle('left'),
top:    element.getStyle('top'),
width:  element.getStyle('width'),
height: element.getStyle('height')});
element.setStyle({
position: 'absolute',
top:    offset.top + 'px',
left:   offset.left + 'px',
width:  layout.get('width') + 'px',
height: layout.get('height') + 'px'});
return element;}
function relativize(element) {
element = prototype$(element);
if (Element.getStyle(element, 'position') === 'relative') {
return element;}
var originalStyles =
element.retrieve('prototype_absolutize_original_styles');
if (originalStyles) element.setStyle(originalStyles);
return element;}
function scrollTo(element) {
element = prototype$(element);
var pos = Element.cumulativeOffset(element);
window.scrollTo(pos.left, pos.top);
return element;}
function makePositioned(element) {
element = prototype$(element);
var position = Element.getStyle(element, 'position'), styles = {};
if (position === 'static' || !position) {
styles.position = 'relative';
if (Prototype.Browser.Opera) {
styles.top  = 0;
styles.left = 0;}
Element.setStyle(element, styles);
Element.store(element, 'prototype_made_positioned', true);}
return element;}
function undoPositioned(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
madePositioned = storage.get('prototype_made_positioned');
if (madePositioned) {
storage.unset('prototype_made_positioned');
Element.setStyle(element, {
position: '',
top:      '',
bottom:   '',
left:     '',
right:    ''});}
return element;}
function makeClipping(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
madeClipping = storage.get('prototype_made_clipping');
if (Object.isUndefined(madeClipping)) {
var overflow = Element.getStyle(element, 'overflow');
storage.set('prototype_made_clipping', overflow);
if (overflow !== 'hidden')
element.style.overflow = 'hidden';}
return element;}
function undoClipping(element) {
element = prototype$(element);
var storage = Element.getStorage(element),
overflow = storage.get('prototype_made_clipping');
if (!Object.isUndefined(overflow)) {
storage.unset('prototype_made_clipping');
element.style.overflow = overflow || '';}
return element;}
function clonePosition(element, source, options) {
options = Object.extend({
setLeft:    true,
setTop:     true,
setWidth:   true,
setHeight:  true,
offsetTop:  0,
offsetLeft: 0
}, options || {});
source  = prototype$(source);
element = prototype$(element);
var p, delta, layout, styles = {};
if (options.setLeft || options.setTop) {
p = Element.viewportOffset(source);
delta = [0, 0];
if (Element.getStyle(element, 'position') === 'absolute') {
var parent = Element.getOffsetParent(element);
if (parent !== document.body) delta = Element.viewportOffset(parent);}}
if (options.setWidth || options.setHeight) {
layout = Element.getLayout(source);}
if (options.setLeft)
styles.left = (p[0] - delta[0] + options.offsetLeft) + 'px';
if (options.setTop)
styles.top  = (p[1] - delta[1] + options.offsetTop)  + 'px';
if (options.setWidth)
styles.width  = layout.get('border-box-width')  + 'px';
if (options.setHeight)
styles.height = layout.get('border-box-height') + 'px';
return Element.setStyle(element, styles);}
if (Prototype.Browser.IE) {
getOffsetParent = getOffsetParent.wrap(
function(proceed, element) {
element = prototype$(element);
if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
return prototype$(document.body);
var position = element.getStyle('position');
if (position !== 'static') return proceed(element);
element.setStyle({ position: 'relative' });
var value = proceed(element);
element.setStyle({ position: position });
return value;}
);
positionedOffset = positionedOffset.wrap(function(proceed, element) {
element = prototype$(element);
if (!element.parentNode) return new Element.Offset(0, 0);
var position = element.getStyle('position');
if (position !== 'static') return proceed(element);
var offsetParent = element.getOffsetParent();
if (offsetParent && offsetParent.getStyle('position') === 'fixed')
hasLayout(offsetParent);
element.setStyle({ position: 'relative' });
var value = proceed(element);
element.setStyle({ position: position });
return value;});
} else if (Prototype.Browser.Webkit) {
cumulativeOffset = function(element) {
element = prototype$(element);
var valueT = 0, valueL = 0;
do {
valueT += element.offsetTop  || 0;
valueL += element.offsetLeft || 0;
if (element.offsetParent == document.body) {
if (Element.getStyle(element, 'position') == 'absolute') break;}
element = element.offsetParent;
} while (element);
return new Element.Offset(valueL, valueT);};}
Element.addMethods({
getLayout:              getLayout,
measure:                measure,
getWidth:               getWidth,
getHeight:              getHeight,
getDimensions:          getDimensions,
getOffsetParent:        getOffsetParent,
cumulativeOffset:       cumulativeOffset,
positionedOffset:       positionedOffset,
cumulativeScrollOffset: cumulativeScrollOffset,
viewportOffset:         viewportOffset,
absolutize:             absolutize,
relativize:             relativize,
scrollTo:               scrollTo,
makePositioned:         makePositioned,
undoPositioned:         undoPositioned,
makeClipping:           makeClipping,
undoClipping:           undoClipping,
clonePosition:          clonePosition});
function isBody(element) {
return element.nodeName.toUpperCase() === 'BODY';}
function isHtml(element) {
return element.nodeName.toUpperCase() === 'HTML';}
function isDocument(element) {
return element.nodeType === Node.DOCUMENT_NODE;}
function isDetached(element) {
return element !== document.body &&
!Element.descendantOf(element, document.body);}
if ('getBoundingClientRect' in document.documentElement) {
Element.addMethods({
viewportOffset: function(element) {
element = prototype$(element);
if (isDetached(element)) return new Element.Offset(0, 0);
var rect = element.getBoundingClientRect(),
docEl = document.documentElement;
return new Element.Offset(rect.left - docEl.clientLeft,
rect.top - docEl.clientTop);}});}
})();
(function() {
var IS_OLD_OPERA = Prototype.Browser.Opera &&
(window.parseFloat(window.opera.version()) < 9.5);
var ROOT = null;
function getRootElement() {
if (ROOT) return ROOT;
ROOT = IS_OLD_OPERA ? document.body : document.documentElement;
return ROOT;}
function getDimensions() {
return { width: this.getWidth(), height: this.getHeight() };}
function getWidth() {
return getRootElement().clientWidth;}
function getHeight() {
return getRootElement().clientHeight;}
function getScrollOffsets() {
var x = window.pageXOffset || document.documentElement.scrollLeft ||
document.body.scrollLeft;
var y = window.pageYOffset || document.documentElement.scrollTop ||
document.body.scrollTop;
return new Element.Offset(x, y);}
document.viewport = {
getDimensions:    getDimensions,
getWidth:         getWidth,
getHeight:        getHeight,
getScrollOffsets: getScrollOffsets};
})();
window.$$ = function() {
var expression = $A(arguments).join(', ');
return Prototype.Selector.select(expression, document);};
Prototype.Selector = (function() {
function select() {
throw new Error('Method "Prototype.Selector.select" must be defined.');}
function match() {
throw new Error('Method "Prototype.Selector.match" must be defined.');}
function find(elements, expression, index) {
index = index || 0;
var match = Prototype.Selector.match, length = elements.length, matchIndex = 0, i;
for (i = 0; i < length; i++) {
if (match(elements[i], expression) && index == matchIndex++) {
return Element.extend(elements[i]);}}}
function extendElements(elements) {
for (var i = 0, length = elements.length; i < length; i++) {
Element.extend(elements[i]);}
return elements;}
var K = Prototype.K;
return {
select: select,
match: match,
find: find,
extendElements: (Element.extend === K) ? K : extendElements,
extendElement: Element.extend};
})();
(function(){
var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
done = 0,
toString = Object.prototype.toString,
hasDuplicate = false,
baseHasDuplicate = true,
rBackslash = /\\/g,
rNonWord = /\W/;
[0, 0].sort(function() {
baseHasDuplicate = false;
return 0;});
var Sizzle = function( selector, context, results, seed ) {
results = results || [];
context = context || document;
var origContext = context;
if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
return [];}
if ( !selector || typeof selector !== "string" ) {
return results;}
var m, set, checkSet, extra, ret, cur, pop, i,
prune = true,
contextXML = Sizzle.isXML( context ),
parts = [],
soFar = selector;
do {
chunker.exec( "" );
m = chunker.exec( soFar );
if ( m ) {
soFar = m[3];
parts.push( m[1] );
if ( m[2] ) {
extra = m[3];
break;}}
} while ( m );
if ( parts.length > 1 && origPOS.exec( selector ) ) {
if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
set = posProcess( parts[0] + parts[1], context );
} else {
set = Expr.relative[ parts[0] ] ?
[ context ] :
Sizzle( parts.shift(), context );
while ( parts.length ) {
selector = parts.shift();
if ( Expr.relative[ selector ] ) {
selector += parts.shift();}
set = posProcess( selector, set );}}
} else {
if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
ret = Sizzle.find( parts.shift(), context, contextXML );
context = ret.expr ?
Sizzle.filter( ret.expr, ret.set )[0] :
ret.set[0];}
if ( context ) {
ret = seed ?
{ expr: parts.pop(), set: makeArray(seed) } :
Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
set = ret.expr ?
Sizzle.filter( ret.expr, ret.set ) :
ret.set;
if ( parts.length > 0 ) {
checkSet = makeArray( set );
} else {
prune = false;}
while ( parts.length ) {
cur = parts.pop();
pop = cur;
if ( !Expr.relative[ cur ] ) {
cur = "";
} else {
pop = parts.pop();}
if ( pop == null ) {
pop = context;}
Expr.relative[ cur ]( checkSet, pop, contextXML );}
} else {
checkSet = parts = [];}}
if ( !checkSet ) {
checkSet = set;}
if ( !checkSet ) {
Sizzle.error( cur || selector );}
if ( toString.call(checkSet) === "[object Array]" ) {
if ( !prune ) {
results.push.apply( results, checkSet );
} else if ( context && context.nodeType === 1 ) {
for ( i = 0; checkSet[i] != null; i++ ) {
if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
results.push( set[i] );}}
} else {
for ( i = 0; checkSet[i] != null; i++ ) {
if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
results.push( set[i] );}}}
} else {
makeArray( checkSet, results );}
if ( extra ) {
Sizzle( extra, origContext, results, seed );
Sizzle.uniqueSort( results );}
return results;};
Sizzle.uniqueSort = function( results ) {
if ( sortOrder ) {
hasDuplicate = baseHasDuplicate;
results.sort( sortOrder );
if ( hasDuplicate ) {
for ( var i = 1; i < results.length; i++ ) {
if ( results[i] === results[ i - 1 ] ) {
results.splice( i--, 1 );}}}}
return results;};
Sizzle.matches = function( expr, set ) {
return Sizzle( expr, null, null, set );};
Sizzle.matchesSelector = function( node, expr ) {
return Sizzle( expr, null, null, [node] ).length > 0;};
Sizzle.find = function( expr, context, isXML ) {
var set;
if ( !expr ) {
return [];}
for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
var match,
type = Expr.order[i];
if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
var left = match[1];
match.splice( 1, 1 );
if ( left.substr( left.length - 1 ) !== "\\" ) {
match[1] = (match[1] || "").replace( rBackslash, "" );
set = Expr.find[ type ]( match, context, isXML );
if ( set != null ) {
expr = expr.replace( Expr.match[ type ], "" );
break;}}}}
if ( !set ) {
set = typeof context.getElementsByTagName !== "undefined" ?
context.getElementsByTagName( "*" ) :
[];}
return { set: set, expr: expr };};
Sizzle.filter = function( expr, set, inplace, not ) {
var match, anyFound,
old = expr,
result = [],
curLoop = set,
isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
while ( expr && set.length ) {
for ( var type in Expr.filter ) {
if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
var found, item,
filter = Expr.filter[ type ],
left = match[1];
anyFound = false;
match.splice(1,1);
if ( left.substr( left.length - 1 ) === "\\" ) {
continue;}
if ( curLoop === result ) {
result = [];}
if ( Expr.preFilter[ type ] ) {
match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
if ( !match ) {
anyFound = found = true;
} else if ( match === true ) {
continue;}}
if ( match ) {
for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
if ( item ) {
found = filter( item, match, i, curLoop );
var pass = not ^ !!found;
if ( inplace && found != null ) {
if ( pass ) {
anyFound = true;
} else {
curLoop[i] = false;}
} else if ( pass ) {
result.push( item );
anyFound = true;}}}}
if ( found !== undefined ) {
if ( !inplace ) {
curLoop = result;}
expr = expr.replace( Expr.match[ type ], "" );
if ( !anyFound ) {
return [];}
break;}}}
if ( expr === old ) {
if ( anyFound == null ) {
Sizzle.error( expr );
} else {
break;}}
old = expr;}
return curLoop;};
Sizzle.error = function( msg ) {
throw "Syntax error, unrecognized expression: " + msg;};
var Expr = Sizzle.selectors = {
order: [ "ID", "NAME", "TAG" ],
match: {
ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},
leftMatch: {},
attrMap: {
"class": "className",
"for": "htmlFor"},
attrHandle: {
href: function( elem ) {
return elem.getAttribute( "href" );},
type: function( elem ) {
return elem.getAttribute( "type" );}},
relative: {
"+": function(checkSet, part){
var isPartStr = typeof part === "string",
isTag = isPartStr && !rNonWord.test( part ),
isPartStrNotTag = isPartStr && !isTag;
if ( isTag ) {
part = part.toLowerCase();}
for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
if ( (elem = checkSet[i]) ) {
while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
elem || false :
elem === part;}}
if ( isPartStrNotTag ) {
Sizzle.filter( part, checkSet, true );}},
">": function( checkSet, part ) {
var elem,
isPartStr = typeof part === "string",
i = 0,
l = checkSet.length;
if ( isPartStr && !rNonWord.test( part ) ) {
part = part.toLowerCase();
for ( ; i < l; i++ ) {
elem = checkSet[i];
if ( elem ) {
var parent = elem.parentNode;
checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;}}
} else {
for ( ; i < l; i++ ) {
elem = checkSet[i];
if ( elem ) {
checkSet[i] = isPartStr ?
elem.parentNode :
elem.parentNode === part;}}
if ( isPartStr ) {
Sizzle.filter( part, checkSet, true );}}},
"": function(checkSet, part, isXML){
var nodeCheck,
doneName = done++,
checkFn = dirCheck;
if ( typeof part === "string" && !rNonWord.test( part ) ) {
part = part.toLowerCase();
nodeCheck = part;
checkFn = dirNodeCheck;}
checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );},
"~": function( checkSet, part, isXML ) {
var nodeCheck,
doneName = done++,
checkFn = dirCheck;
if ( typeof part === "string" && !rNonWord.test( part ) ) {
part = part.toLowerCase();
nodeCheck = part;
checkFn = dirNodeCheck;}
checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );}},
find: {
ID: function( match, context, isXML ) {
if ( typeof context.getElementById !== "undefined" && !isXML ) {
var m = context.getElementById(match[1]);
return m && m.parentNode ? [m] : [];}},
NAME: function( match, context ) {
if ( typeof context.getElementsByName !== "undefined" ) {
var ret = [],
results = context.getElementsByName( match[1] );
for ( var i = 0, l = results.length; i < l; i++ ) {
if ( results[i].getAttribute("name") === match[1] ) {
ret.push( results[i] );}}
return ret.length === 0 ? null : ret;}},
TAG: function( match, context ) {
if ( typeof context.getElementsByTagName !== "undefined" ) {
return context.getElementsByTagName( match[1] );}}},
preFilter: {
CLASS: function( match, curLoop, inplace, result, not, isXML ) {
match = " " + match[1].replace( rBackslash, "" ) + " ";
if ( isXML ) {
return match;}
for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
if ( elem ) {
if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
if ( !inplace ) {
result.push( elem );}
} else if ( inplace ) {
curLoop[i] = false;}}}
return false;},
ID: function( match ) {
return match[1].replace( rBackslash, "" );},
TAG: function( match, curLoop ) {
return match[1].replace( rBackslash, "" ).toLowerCase();},
CHILD: function( match ) {
if ( match[1] === "nth" ) {
if ( !match[2] ) {
Sizzle.error( match[0] );}
match[2] = match[2].replace(/^\+|\s*/g, '');
var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
match[2] = (test[1] + (test[2] || 1)) - 0;
match[3] = test[3] - 0;}
else if ( match[2] ) {
Sizzle.error( match[0] );}
match[0] = done++;
return match;},
ATTR: function( match, curLoop, inplace, result, not, isXML ) {
var name = match[1] = match[1].replace( rBackslash, "" );
if ( !isXML && Expr.attrMap[name] ) {
match[1] = Expr.attrMap[name];}
match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
if ( match[2] === "~=" ) {
match[4] = " " + match[4] + " ";}
return match;},
PSEUDO: function( match, curLoop, inplace, result, not ) {
if ( match[1] === "not" ) {
if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
match[3] = Sizzle(match[3], null, null, curLoop);
} else {
var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
if ( !inplace ) {
result.push.apply( result, ret );}
return false;}
} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
return true;}
return match;},
POS: function( match ) {
match.unshift( true );
return match;}},
filters: {
enabled: function( elem ) {
return elem.disabled === false && elem.type !== "hidden";},
disabled: function( elem ) {
return elem.disabled === true;},
checked: function( elem ) {
return elem.checked === true;},
selected: function( elem ) {
if ( elem.parentNode ) {
elem.parentNode.selectedIndex;}
return elem.selected === true;},
parent: function( elem ) {
return !!elem.firstChild;},
empty: function( elem ) {
return !elem.firstChild;},
has: function( elem, i, match ) {
return !!Sizzle( match[3], elem ).length;},
header: function( elem ) {
return (/h\d/i).test( elem.nodeName );},
text: function( elem ) {
var attr = elem.getAttribute( "type" ), type = elem.type;
return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );},
radio: function( elem ) {
return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;},
checkbox: function( elem ) {
return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;},
file: function( elem ) {
return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;},
password: function( elem ) {
return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;},
submit: function( elem ) {
var name = elem.nodeName.toLowerCase();
return (name === "input" || name === "button") && "submit" === elem.type;},
image: function( elem ) {
return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;},
reset: function( elem ) {
var name = elem.nodeName.toLowerCase();
return (name === "input" || name === "button") && "reset" === elem.type;},
button: function( elem ) {
var name = elem.nodeName.toLowerCase();
return name === "input" && "button" === elem.type || name === "button";},
input: function( elem ) {
return (/input|select|textarea|button/i).test( elem.nodeName );},
focus: function( elem ) {
return elem === elem.ownerDocument.activeElement;}},
setFilters: {
first: function( elem, i ) {
return i === 0;},
last: function( elem, i, match, array ) {
return i === array.length - 1;},
even: function( elem, i ) {
return i % 2 === 0;},
odd: function( elem, i ) {
return i % 2 === 1;},
lt: function( elem, i, match ) {
return i < match[3] - 0;},
gt: function( elem, i, match ) {
return i > match[3] - 0;},
nth: function( elem, i, match ) {
return match[3] - 0 === i;},
eq: function( elem, i, match ) {
return match[3] - 0 === i;}},
filter: {
PSEUDO: function( elem, match, i, array ) {
var name = match[1],
filter = Expr.filters[ name ];
if ( filter ) {
return filter( elem, i, match, array );
} else if ( name === "contains" ) {
return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;
} else if ( name === "not" ) {
var not = match[3];
for ( var j = 0, l = not.length; j < l; j++ ) {
if ( not[j] === elem ) {
return false;}}
return true;
} else {
Sizzle.error( name );}},
CHILD: function( elem, match ) {
var type = match[1],
node = elem;
switch ( type ) {
case "only":
case "first":
while ( (node = node.previousSibling) )	 {
if ( node.nodeType === 1 ) {
return false;}}
if ( type === "first" ) {
return true;}
node = elem;
case "last":
while ( (node = node.nextSibling) )	 {
if ( node.nodeType === 1 ) {
return false;}}
return true;
case "nth":
var first = match[2],
last = match[3];
if ( first === 1 && last === 0 ) {
return true;}
var doneName = match[0],
parent = elem.parentNode;
if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
var count = 0;
for ( node = parent.firstChild; node; node = node.nextSibling ) {
if ( node.nodeType === 1 ) {
node.nodeIndex = ++count;}}
parent.sizcache = doneName;}
var diff = elem.nodeIndex - last;
if ( first === 0 ) {
return diff === 0;
} else {
return ( diff % first === 0 && diff / first >= 0 );}}},
ID: function( elem, match ) {
return elem.nodeType === 1 && elem.getAttribute("id") === match;},
TAG: function( elem, match ) {
return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;},
CLASS: function( elem, match ) {
return (" " + (elem.className || elem.getAttribute("class")) + " ")
.indexOf( match ) > -1;},
ATTR: function( elem, match ) {
var name = match[1],
result = Expr.attrHandle[ name ] ?
Expr.attrHandle[ name ]( elem ) :
elem[ name ] != null ?
elem[ name ] :
elem.getAttribute( name ),
value = result + "",
type = match[2],
check = match[4];
return result == null ?
type === "!=" :
type === "=" ?
value === check :
type === "*=" ?
value.indexOf(check) >= 0 :
type === "~=" ?
(" " + value + " ").indexOf(check) >= 0 :
!check ?
value && result !== false :
type === "!=" ?
value !== check :
type === "^=" ?
value.indexOf(check) === 0 :
type === "$=" ?
value.substr(value.length - check.length) === check :
type === "|=" ?
value === check || value.substr(0, check.length + 1) === check + "-" :
false;},
POS: function( elem, match, i, array ) {
var name = match[2],
filter = Expr.setFilters[ name ];
if ( filter ) {
return filter( elem, i, match, array );}}}};
var origPOS = Expr.match.POS,
fescape = function(all, num){
return "\\" + (num - 0 + 1);};
for ( var type in Expr.match ) {
Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );}
var makeArray = function( array, results ) {
array = Array.prototype.slice.call( array, 0 );
if ( results ) {
results.push.apply( results, array );
return results;}
return array;};
try {
Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
} catch( e ) {
makeArray = function( array, results ) {
var i = 0,
ret = results || [];
if ( toString.call(array) === "[object Array]" ) {
Array.prototype.push.apply( ret, array );
} else {
if ( typeof array.length === "number" ) {
for ( var l = array.length; i < l; i++ ) {
ret.push( array[i] );}
} else {
for ( ; array[i]; i++ ) {
ret.push( array[i] );}}}
return ret;};}
var sortOrder, siblingCheck;
if ( document.documentElement.compareDocumentPosition ) {
sortOrder = function( a, b ) {
if ( a === b ) {
hasDuplicate = true;
return 0;}
if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
return a.compareDocumentPosition ? -1 : 1;}
return a.compareDocumentPosition(b) & 4 ? -1 : 1;};
} else {
sortOrder = function( a, b ) {
if ( a === b ) {
hasDuplicate = true;
return 0;
} else if ( a.sourceIndex && b.sourceIndex ) {
return a.sourceIndex - b.sourceIndex;}
var al, bl,
ap = [],
bp = [],
aup = a.parentNode,
bup = b.parentNode,
cur = aup;
if ( aup === bup ) {
return siblingCheck( a, b );
} else if ( !aup ) {
return -1;
} else if ( !bup ) {
return 1;}
while ( cur ) {
ap.unshift( cur );
cur = cur.parentNode;}
cur = bup;
while ( cur ) {
bp.unshift( cur );
cur = cur.parentNode;}
al = ap.length;
bl = bp.length;
for ( var i = 0; i < al && i < bl; i++ ) {
if ( ap[i] !== bp[i] ) {
return siblingCheck( ap[i], bp[i] );}}
return i === al ?
siblingCheck( a, bp[i], -1 ) :
siblingCheck( ap[i], b, 1 );};
siblingCheck = function( a, b, ret ) {
if ( a === b ) {
return ret;}
var cur = a.nextSibling;
while ( cur ) {
if ( cur === b ) {
return -1;}
cur = cur.nextSibling;}
return 1;};}
Sizzle.getText = function( elems ) {
var ret = "", elem;
for ( var i = 0; elems[i]; i++ ) {
elem = elems[i];
if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
ret += elem.nodeValue;
} else if ( elem.nodeType !== 8 ) {
ret += Sizzle.getText( elem.childNodes );}}
return ret;};
(function(){
var form = document.createElement("div"),
id = "script" + (new Date()).getTime(),
root = document.documentElement;
form.innerHTML = "<a name='" + id + "'/>";
root.insertBefore( form, root.firstChild );
if ( document.getElementById( id ) ) {
Expr.find.ID = function( match, context, isXML ) {
if ( typeof context.getElementById !== "undefined" && !isXML ) {
var m = context.getElementById(match[1]);
return m ?
m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
[m] :
undefined :
[];}};
Expr.filter.ID = function( elem, match ) {
var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
return elem.nodeType === 1 && node && node.nodeValue === match;};}
root.removeChild( form );
root = form = null;
})();
(function(){
var div = document.createElement("div");
div.appendChild( document.createComment("") );
if ( div.getElementsByTagName("*").length > 0 ) {
Expr.find.TAG = function( match, context ) {
var results = context.getElementsByTagName( match[1] );
if ( match[1] === "*" ) {
var tmp = [];
for ( var i = 0; results[i]; i++ ) {
if ( results[i].nodeType === 1 ) {
tmp.push( results[i] );}}
results = tmp;}
return results;};}
div.innerHTML = "<a href='#'></a>";
if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
div.firstChild.getAttribute("href") !== "#" ) {
Expr.attrHandle.href = function( elem ) {
return elem.getAttribute( "href", 2 );};}
div = null;
})();
if ( document.querySelectorAll ) {
(function(){
var oldSizzle = Sizzle,
div = document.createElement("div"),
id = "__sizzle__";
div.innerHTML = "<p class='TEST'></p>";
if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
return;}
Sizzle = function( query, context, extra, seed ) {
context = context || document;
if ( !seed && !Sizzle.isXML(context) ) {
var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
if ( match[1] ) {
return makeArray( context.getElementsByTagName( query ), extra );
} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
return makeArray( context.getElementsByClassName( match[2] ), extra );}}
if ( context.nodeType === 9 ) {
if ( query === "body" && context.body ) {
return makeArray( [ context.body ], extra );
} else if ( match && match[3] ) {
var elem = context.getElementById( match[3] );
if ( elem && elem.parentNode ) {
if ( elem.id === match[3] ) {
return makeArray( [ elem ], extra );}
} else {
return makeArray( [], extra );}}
try {
return makeArray( context.querySelectorAll(query), extra );
} catch(qsaError) {}
} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
var oldContext = context,
old = context.getAttribute( "id" ),
nid = old || id,
hasParent = context.parentNode,
relativeHierarchySelector = /^\s*[+~]/.test( query );
if ( !old ) {
context.setAttribute( "id", nid );
} else {
nid = nid.replace( /'/g, "\\$&" );}
if ( relativeHierarchySelector && hasParent ) {
context = context.parentNode;}
try {
if ( !relativeHierarchySelector || hasParent ) {
return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );}
} catch(pseudoError) {
} finally {
if ( !old ) {
oldContext.removeAttribute( "id" );}}}}
return oldSizzle(query, context, extra, seed);};
for ( var prop in oldSizzle ) {
Sizzle[ prop ] = oldSizzle[ prop ];}
div = null;
})();}
(function(){
var html = document.documentElement,
matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
if ( matches ) {
var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
pseudoWorks = false;
try {
matches.call( document.documentElement, "[test!='']:sizzle" );
} catch( pseudoError ) {
pseudoWorks = true;}
Sizzle.matchesSelector = function( node, expr ) {
expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
if ( !Sizzle.isXML( node ) ) {
try {
if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
var ret = matches.call( node, expr );
if ( ret || !disconnectedMatch ||
node.document && node.document.nodeType !== 11 ) {
return ret;}}
} catch(e) {}}
return Sizzle(expr, null, null, [node]).length > 0;};}
})();
(function(){
var div = document.createElement("div");
div.innerHTML = "<div class='test e'></div><div class='test'></div>";
if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
return;}
div.lastChild.className = "e";
if ( div.getElementsByClassName("e").length === 1 ) {
return;}
Expr.order.splice(1, 0, "CLASS");
Expr.find.CLASS = function( match, context, isXML ) {
if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
return context.getElementsByClassName(match[1]);}};
div = null;
})();
function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
for ( var i = 0, l = checkSet.length; i < l; i++ ) {
var elem = checkSet[i];
if ( elem ) {
var match = false;
elem = elem[dir];
while ( elem ) {
if ( elem.sizcache === doneName ) {
match = checkSet[elem.sizset];
break;}
if ( elem.nodeType === 1 && !isXML ){
elem.sizcache = doneName;
elem.sizset = i;}
if ( elem.nodeName.toLowerCase() === cur ) {
match = elem;
break;}
elem = elem[dir];}
checkSet[i] = match;}}}
function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
for ( var i = 0, l = checkSet.length; i < l; i++ ) {
var elem = checkSet[i];
if ( elem ) {
var match = false;
elem = elem[dir];
while ( elem ) {
if ( elem.sizcache === doneName ) {
match = checkSet[elem.sizset];
break;}
if ( elem.nodeType === 1 ) {
if ( !isXML ) {
elem.sizcache = doneName;
elem.sizset = i;}
if ( typeof cur !== "string" ) {
if ( elem === cur ) {
match = true;
break;}
} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
match = elem;
break;}}
elem = elem[dir];}
checkSet[i] = match;}}}
if ( document.documentElement.contains ) {
Sizzle.contains = function( a, b ) {
return a !== b && (a.contains ? a.contains(b) : true);};
} else if ( document.documentElement.compareDocumentPosition ) {
Sizzle.contains = function( a, b ) {
return !!(a.compareDocumentPosition(b) & 16);};
} else {
Sizzle.contains = function() {
return false;};}
Sizzle.isXML = function( elem ) {
var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
return documentElement ? documentElement.nodeName !== "HTML" : false;};
var posProcess = function( selector, context ) {
var match,
tmpSet = [],
later = "",
root = context.nodeType ? [context] : context;
while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
later += match[0];
selector = selector.replace( Expr.match.PSEUDO, "" );}
selector = Expr.relative[selector] ? selector + "*" : selector;
for ( var i = 0, l = root.length; i < l; i++ ) {
Sizzle( selector, root[i], tmpSet );}
return Sizzle.filter( later, tmpSet );};
window.Sizzle = Sizzle;
})();
Prototype._original_property = window.Sizzle;
;(function(engine) {
var extendElements = Prototype.Selector.extendElements;
function select(selector, scope) {
return extendElements(engine(selector, scope || document));}
function match(element, selector) {
return engine.matches(selector, [element]).length == 1;}
Prototype.Selector.engine = engine;
Prototype.Selector.select = select;
Prototype.Selector.match = match;
})(Sizzle);
window.Sizzle = Prototype._original_property;
delete Prototype._original_property;
var Form = {
reset: function(form) {
form = prototype$(form);
form.reset();
return form;},
serializeElements: function(elements, options) {
if (typeof options != 'object') options = { hash: !!options };
else if (Object.isUndefined(options.hash)) options.hash = true;
var key, value, submitted = false, submit = options.submit, accumulator, initial;
if (options.hash) {
initial = {};
accumulator = function(result, key, value) {
if (key in result) {
if (!Object.isArray(result[key])) result[key] = [result[key]];
result[key].push(value);
} else result[key] = value;
return result;};
} else {
initial = '';
accumulator = function(result, key, value) {
value = value.gsub(/(\r)?\n/, '\r\n');
value = encodeURIComponent(value);
value = value.gsub(/%20/, '+');
return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;}}
return elements.inject(initial, function(result, element) {
if (!element.disabled && element.name) {
key = element.name; value = prototype$(element).getValue();
if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
submit !== false && (!submit || key == submit) && (submitted = true)))) {
result = accumulator(result, key, value);}}
return result;});}};
Form.Methods = {
serialize: function(form, options) {
return Form.serializeElements(Form.getElements(form), options);},
getElements: function(form) {
var elements = prototype$(form).getElementsByTagName('*');
var element, results = [], serializers = Form.Element.Serializers;
for (var i = 0; element = elements[i]; i++) {
if (serializers[element.tagName.toLowerCase()])
results.push(Element.extend(element));}
return results;},
getInputs: function(form, typeName, name) {
form = prototype$(form);
var inputs = form.getElementsByTagName('input');
if (!typeName && !name) return $A(inputs).map(Element.extend);
for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
var input = inputs[i];
if ((typeName && input.type != typeName) || (name && input.name != name))
continue;
matchingInputs.push(Element.extend(input));}
return matchingInputs;},
disable: function(form) {
form = prototype$(form);
Form.getElements(form).invoke('disable');
return form;},
enable: function(form) {
form = prototype$(form);
Form.getElements(form).invoke('enable');
return form;},
findFirstElement: function(form) {
var elements = prototype$(form).getElements().findAll(function(element) {
return 'hidden' != element.type && !element.disabled;});
var firstByIndex = elements.findAll(function(element) {
return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
}).sortBy(function(element) { return element.tabIndex }).first();
return firstByIndex ? firstByIndex : elements.find(function(element) {
return /^(?:input|select|textarea)$/i.test(element.tagName);});},
focusFirstElement: function(form) {
form = prototype$(form);
var element = form.findFirstElement();
if (element) element.activate();
return form;},
request: function(form, options) {
form = prototype$(form), options = Object.clone(options || { });
var params = options.parameters, action = form.readAttribute('action') || '';
if (action.blank()) action = window.location.href;
options.parameters = form.serialize(true);
if (params) {
if (Object.isString(params)) params = params.toQueryParams();
Object.extend(options.parameters, params);}
if (form.hasAttribute('method') && !options.method)
options.method = form.method;
return new Ajax.Request(action, options);}};
Form.Element = {
focus: function(element) {
prototype$(element).focus();
return element;},
select: function(element) {
prototype$(element).select();
return element;}};
Form.Element.Methods = {
serialize: function(element) {
element = prototype$(element);
if (!element.disabled && element.name) {
var value = element.getValue();
if (value != undefined) {
var pair = { };
pair[element.name] = value;
return Object.toQueryString(pair);}}
return '';},
getValue: function(element) {
element = prototype$(element);
var method = element.tagName.toLowerCase();
return Form.Element.Serializers[method](element);},
setValue: function(element, value) {
element = prototype$(element);
var method = element.tagName.toLowerCase();
Form.Element.Serializers[method](element, value);
return element;},
clear: function(element) {
prototype$(element).value = '';
return element;},
present: function(element) {
return prototype$(element).value != '';},
activate: function(element) {
element = prototype$(element);
try {
element.focus();
if (element.select && (element.tagName.toLowerCase() != 'input' ||
!(/^(?:button|reset|submit)$/i.test(element.type))))
element.select();
} catch (e) { }
return element;},
disable: function(element) {
element = prototype$(element);
element.disabled = true;
return element;},
enable: function(element) {
element = prototype$(element);
element.disabled = false;
return element;}};
var Field = Form.Element;
var $F = Form.Element.Methods.getValue;
Form.Element.Serializers = (function() {
function input(element, value) {
switch (element.type.toLowerCase()) {
case 'checkbox':
case 'radio':
return inputSelector(element, value);
default:
return valueSelector(element, value);}}
function inputSelector(element, value) {
if (Object.isUndefined(value))
return element.checked ? element.value : null;
else element.checked = !!value;}
function valueSelector(element, value) {
if (Object.isUndefined(value)) return element.value;
else element.value = value;}
function select(element, value) {
if (Object.isUndefined(value))
return (element.type === 'select-one' ? selectOne : selectMany)(element);
var opt, currentValue, single = !Object.isArray(value);
for (var i = 0, length = element.length; i < length; i++) {
opt = element.options[i];
currentValue = this.optionValue(opt);
if (single) {
if (currentValue == value) {
opt.selected = true;
return;}}
else opt.selected = value.include(currentValue);}}
function selectOne(element) {
var index = element.selectedIndex;
return index >= 0 ? optionValue(element.options[index]) : null;}
function selectMany(element) {
var values, length = element.length;
if (!length) return null;
for (var i = 0, values = []; i < length; i++) {
var opt = element.options[i];
if (opt.selected) values.push(optionValue(opt));}
return values;}
function optionValue(opt) {
return Element.hasAttribute(opt, 'value') ? opt.value : opt.text;}
return {
input:         input,
inputSelector: inputSelector,
textarea:      valueSelector,
select:        select,
selectOne:     selectOne,
selectMany:    selectMany,
optionValue:   optionValue,
button:        valueSelector};
})();
Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
initialize: function($super, element, frequency, callback) {
$super(callback, frequency);
this.element   = prototype$(element);
this.lastValue = this.getValue();},
execute: function() {
var value = this.getValue();
if (Object.isString(this.lastValue) && Object.isString(value) ?
this.lastValue != value : String(this.lastValue) != String(value)) {
this.callback(this.element, value);
this.lastValue = value;}}});
Form.Element.Observer = Class.create(Abstract.TimedObserver, {
getValue: function() {
return Form.Element.getValue(this.element);}});
Form.Observer = Class.create(Abstract.TimedObserver, {
getValue: function() {
return Form.serialize(this.element);}});
Abstract.EventObserver = Class.create({
initialize: function(element, callback) {
this.element  = prototype$(element);
this.callback = callback;
this.lastValue = this.getValue();
if (this.element.tagName.toLowerCase() == 'form')
this.registerFormCallbacks();
else
this.registerCallback(this.element);},
onElementEvent: function() {
var value = this.getValue();
if (this.lastValue != value) {
this.callback(this.element, value);
this.lastValue = value;}},
registerFormCallbacks: function() {
Form.getElements(this.element).each(this.registerCallback, this);},
registerCallback: function(element) {
if (element.type) {
switch (element.type.toLowerCase()) {
case 'checkbox':
case 'radio':
Event.observe(element, 'click', this.onElementEvent.bind(this));
break;
default:
Event.observe(element, 'change', this.onElementEvent.bind(this));
break;}}}});
Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
getValue: function() {
return Form.Element.getValue(this.element);}});
Form.EventObserver = Class.create(Abstract.EventObserver, {
getValue: function() {
return Form.serialize(this.element);}});
(function(GLOBAL) {
var DIV = document.createElement('div');
var docEl = document.documentElement;
var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
&& 'onmouseleave' in docEl;
var Event = {
KEY_BACKSPACE: 8,
KEY_TAB:       9,
KEY_RETURN:   13,
KEY_ESC:      27,
KEY_LEFT:     37,
KEY_UP:       38,
KEY_RIGHT:    39,
KEY_DOWN:     40,
KEY_DELETE:   46,
KEY_HOME:     36,
KEY_END:      35,
KEY_PAGEUP:   33,
KEY_PAGEDOWN: 34,
KEY_INSERT:   45};
var isIELegacyEvent = function(event) { return false; };
if (window.attachEvent) {
if (window.addEventListener) {
isIELegacyEvent = function(event) {
return !(event instanceof window.Event);};
} else {
isIELegacyEvent = function(event) { return true; };}}
var _isButton;
function _isButtonForDOMEvents(event, code) {
return event.which ? (event.which === code + 1) : (event.button === code);}
var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
function _isButtonForLegacyEvents(event, code) {
return event.button === legacyButtonMap[code];}
function _isButtonForWebKit(event, code) {
switch (code) {
case 0: return event.which == 1 && !event.metaKey;
case 1: return event.which == 2 || (event.which == 1 && event.metaKey);
case 2: return event.which == 3;
default: return false;}}
if (window.attachEvent) {
if (!window.addEventListener) {
_isButton = _isButtonForLegacyEvents;
} else {
_isButton = function(event, code) {
return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
_isButtonForDOMEvents(event, code);}}
} else if (Prototype.Browser.WebKit) {
_isButton = _isButtonForWebKit;
} else {
_isButton = _isButtonForDOMEvents;}
function isLeftClick(event)   { return _isButton(event, 0) }
function isMiddleClick(event) { return _isButton(event, 1) }
function isRightClick(event)  { return _isButton(event, 2) }
function element(event) {
return Element.extend(_element(event));}
function _element(event) {
event = Event.extend(event);
var node = event.target, type = event.type,
currentTarget = event.currentTarget;
if (currentTarget && currentTarget.tagName) {
if (type === 'load' || type === 'error' ||
(type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
&& currentTarget.type === 'radio'))
node = currentTarget;}
if (node.nodeType == Node.TEXT_NODE)
node = node.parentNode;
return Element.extend(node);}
function findElement(event, expression) {
var element = _element(event), match = Prototype.Selector.match;
if (!expression) return Element.extend(element);
while (element) {
if (Object.isElement(element) && match(element, expression))
return Element.extend(element);
element = element.parentNode;}}
function pointer(event) {
return { x: pointerX(event), y: pointerY(event) };}
function pointerX(event) {
var docElement = document.documentElement,
body = document.body || { scrollLeft: 0 };
return event.pageX || (event.clientX +
(docElement.scrollLeft || body.scrollLeft) -
(docElement.clientLeft || 0));}
function pointerY(event) {
var docElement = document.documentElement,
body = document.body || { scrollTop: 0 };
return  event.pageY || (event.clientY +
(docElement.scrollTop || body.scrollTop) -
(docElement.clientTop || 0));}
function stop(event) {
Event.extend(event);
event.preventDefault();
event.stopPropagation();
event.stopped = true;}
Event.Methods = {
isLeftClick:   isLeftClick,
isMiddleClick: isMiddleClick,
isRightClick:  isRightClick,
element:     element,
findElement: findElement,
pointer:  pointer,
pointerX: pointerX,
pointerY: pointerY,
stop: stop};
var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
m[name] = Event.Methods[name].methodize();
return m;});
if (window.attachEvent) {
function _relatedTarget(event) {
var element;
switch (event.type) {
case 'mouseover':
case 'mouseenter':
element = event.fromElement;
break;
case 'mouseout':
case 'mouseleave':
element = event.toElement;
break;
default:
return null;}
return Element.extend(element);}
var additionalMethods = {
stopPropagation: function() { this.cancelBubble = true },
preventDefault:  function() { this.returnValue = false },
inspect: function() { return '[object Event]' }};
Event.extend = function(event, element) {
if (!event) return false;
if (!isIELegacyEvent(event)) return event;
if (event._extendedByPrototype) return event;
event._extendedByPrototype = Prototype.emptyFunction;
var pointer = Event.pointer(event);
Object.extend(event, {
target: event.srcElement || element,
relatedTarget: _relatedTarget(event),
pageX:  pointer.x,
pageY:  pointer.y});
Object.extend(event, methods);
Object.extend(event, additionalMethods);
return event;};
} else {
Event.extend = Prototype.K;}
if (window.addEventListener) {
Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
Object.extend(Event.prototype, methods);}
var EVENT_TRANSLATIONS = {
mouseenter: 'mouseover',
mouseleave: 'mouseout'};
function getDOMEventName(eventName) {
return EVENT_TRANSLATIONS[eventName] || eventName;}
if (MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED)
getDOMEventName = Prototype.K;
function getUniqueElementID(element) {
if (element === window) return 0;
if (typeof element._prototypeUID === 'undefined')
element._prototypeUID = Element.Storage.UID++;
return element._prototypeUID;}
function getUniqueElementID_IE(element) {
if (element === window) return 0;
if (element == document) return 1;
return element.uniqueID;}
if ('uniqueID' in DIV)
getUniqueElementID = getUniqueElementID_IE;
function isCustomEvent(eventName) {
return eventName.include(':');}
Event._isCustomEvent = isCustomEvent;
function getRegistryForElement(element, uid) {
var CACHE = GLOBAL.Event.cache;
if (Object.isUndefined(uid))
uid = getUniqueElementID(element);
if (!CACHE[uid]) CACHE[uid] = { element: element };
return CACHE[uid];}
function destroyRegistryForElement(element, uid) {
if (Object.isUndefined(uid))
uid = getUniqueElementID(element);
delete GLOBAL.Event.cache[uid];}
function register(element, eventName, handler) {
var registry = getRegistryForElement(element);
if (!registry[eventName]) registry[eventName] = [];
var entries = registry[eventName];
var i = entries.length;
while (i--)
if (entries[i].handler === handler) return null;
var uid = getUniqueElementID(element);
var responder = GLOBAL.Event._createResponder(uid, eventName, handler);
var entry = {
responder: responder,
handler:   handler};
entries.push(entry);
return entry;}
function unregister(element, eventName, handler) {
var registry = getRegistryForElement(element);
var entries = registry[eventName];
if (!entries) return;
var i = entries.length, entry;
while (i--) {
if (entries[i].handler === handler) {
entry = entries[i];
break;}}
if (!entry) return;
var index = entries.indexOf(entry);
entries.splice(index, 1);
return entry;}
function observe(element, eventName, handler) {
element = prototype$(element);
var entry = register(element, eventName, handler);
if (entry === null) return element;
var responder = entry.responder;
if (isCustomEvent(eventName))
observeCustomEvent(element, eventName, responder);
else
observeStandardEvent(element, eventName, responder);
return element;}
function observeStandardEvent(element, eventName, responder) {
var actualEventName = getDOMEventName(eventName);
if (element.addEventListener) {
element.addEventListener(actualEventName, responder, false);
} else {
element.attachEvent('on' + actualEventName, responder);}}
function observeCustomEvent(element, eventName, responder) {
if (element.addEventListener) {
element.addEventListener('dataavailable', responder, false);
} else {
element.attachEvent('ondataavailable', responder);
element.attachEvent('onlosecapture',   responder);}}
function stopObserving(element, eventName, handler) {
element = prototype$(element);
var handlerGiven = !Object.isUndefined(handler),
eventNameGiven = !Object.isUndefined(eventName);
if (!eventNameGiven && !handlerGiven) {
stopObservingElement(element);
return element;}
if (!handlerGiven) {
stopObservingEventName(element, eventName);
return element;}
var entry = unregister(element, eventName, handler);
if (!entry) return element;
removeEvent(element, eventName, entry.responder);
return element;}
function stopObservingStandardEvent(element, eventName, responder) {
var actualEventName = getDOMEventName(eventName);
if (element.removeEventListener) {
element.removeEventListener(actualEventName, responder, false);
} else {
element.detachEvent('on' + actualEventName, responder);}}
function stopObservingCustomEvent(element, eventName, responder) {
if (element.removeEventListener) {
element.removeEventListener('dataavailable', responder, false);
} else {
element.detachEvent('ondataavailable', responder);
element.detachEvent('onlosecapture',   responder);}}
function stopObservingElement(element) {
var uid = getUniqueElementID(element),
registry = getRegistryForElement(element, uid);
destroyRegistryForElement(element, uid);
var entries, i;
for (var eventName in registry) {
if (eventName === 'element') continue;
entries = registry[eventName];
i = entries.length;
while (i--)
removeEvent(element, eventName, entries[i].responder);}}
function stopObservingEventName(element, eventName) {
var registry = getRegistryForElement(element);
var entries = registry[eventName];
if (!entries) return;
delete registry[eventName];
var i = entries.length;
while (i--)
removeEvent(element, eventName, entries[i].responder);}
function removeEvent(element, eventName, handler) {
if (isCustomEvent(eventName))
stopObservingCustomEvent(element, eventName, handler);
else
stopObservingStandardEvent(element, eventName, handler);}
function getFireTarget(element) {
if (element !== document) return element;
if (document.createEvent && !element.dispatchEvent)
return document.documentElement;
return element;}
function fire(element, eventName, memo, bubble) {
element = getFireTarget(prototype$(element));
if (Object.isUndefined(bubble)) bubble = true;
memo = memo || {};
var event = fireEvent(element, eventName, memo, bubble);
return Event.extend(event);}
function fireEvent_DOM(element, eventName, memo, bubble) {
var event = document.createEvent('HTMLEvents');
event.initEvent('dataavailable', bubble, true);
event.eventName = eventName;
event.memo = memo;
element.dispatchEvent(event);
return event;}
function fireEvent_IE(element, eventName, memo, bubble) {
var event = document.createEventObject();
event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';
event.eventName = eventName;
event.memo = memo;
element.fireEvent(event.eventType, event);
return event;}
var fireEvent = document.createEvent ? fireEvent_DOM : fireEvent_IE;
Event.Handler = Class.create({
initialize: function(element, eventName, selector, callback) {
this.element   = prototype$(element);
this.eventName = eventName;
this.selector  = selector;
this.callback  = callback;
this.handler   = this.handleEvent.bind(this);},
start: function() {
Event.observe(this.element, this.eventName, this.handler);
return this;},
stop: function() {
Event.stopObserving(this.element, this.eventName, this.handler);
return this;},
handleEvent: function(event) {
var element = Event.findElement(event, this.selector);
if (element) this.callback.call(this.element, event, element);}});
function on(element, eventName, selector, callback) {
element = prototype$(element);
if (Object.isFunction(selector) && Object.isUndefined(callback)) {
callback = selector, selector = null;}
return new Event.Handler(element, eventName, selector, callback).start();}
Object.extend(Event, Event.Methods);
Object.extend(Event, {
fire:          fire,
observe:       observe,
stopObserving: stopObserving,
on:            on});
Element.addMethods({
fire:          fire,
observe:       observe,
stopObserving: stopObserving,
on:            on});
Object.extend(document, {
fire:          fire.methodize(),
observe:       observe.methodize(),
stopObserving: stopObserving.methodize(),
on:            on.methodize(),
loaded:        false});
if (GLOBAL.Event) Object.extend(window.Event, Event);
else GLOBAL.Event = Event;
GLOBAL.Event.cache = {};
function destroyCache_IE() {
GLOBAL.Event.cache = null;}
if (window.attachEvent)
window.attachEvent('onunload', destroyCache_IE);
DIV = null;
docEl = null;
})(this);
(function(GLOBAL) {
var docEl = document.documentElement;
var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
&& 'onmouseleave' in docEl;
function isSimulatedMouseEnterLeaveEvent(eventName) {
return !MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
(eventName === 'mouseenter' || eventName === 'mouseleave');}
function createResponder(uid, eventName, handler) {
if (Event._isCustomEvent(eventName))
return createResponderForCustomEvent(uid, eventName, handler);
if (isSimulatedMouseEnterLeaveEvent(eventName))
return createMouseEnterLeaveResponder(uid, eventName, handler);
return function(event) {
var cacheEntry = Event.cache[uid];
var element = cacheEntry.element;
Event.extend(event, element);
handler.call(element, event);};}
function createResponderForCustomEvent(uid, eventName, handler) {
return function(event) {
var cacheEntry = Event.cache[uid], element = cacheEntry.element;
if (Object.isUndefined(event.eventName))
return false;
if (event.eventName !== eventName)
return false;
Event.extend(event, element);
handler.call(element, event);};}
function createMouseEnterLeaveResponder(uid, eventName, handler) {
return function(event) {
var cacheEntry = Event.cache[uid], element = cacheEntry.element;
Event.extend(event, element);
var parent = event.relatedTarget;
while (parent && parent !== element) {
try { parent = parent.parentNode; }
catch(e) { parent = element; }}
if (parent === element) return;
handler.call(element, event);}}
GLOBAL.Event._createResponder = createResponder;
docEl = null;
})(this);
(function(GLOBAL) {
var TIMER;
function fireContentLoadedEvent() {
if (document.loaded) return;
if (TIMER) window.clearTimeout(TIMER);
document.loaded = true;
document.fire('dom:loaded');}
function checkReadyState() {
if (document.readyState === 'complete') {
document.detachEvent('onreadystatechange', checkReadyState);
fireContentLoadedEvent();}}
function pollDoScroll() {
try {
document.documentElement.doScroll('left');
} catch (e) {
TIMER = pollDoScroll.defer();
return;}
fireContentLoadedEvent();}
if (document.addEventListener) {
document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
} else {
document.attachEvent('onreadystatechange', checkReadyState);
if (window == top) TIMER = pollDoScroll.defer();}
Event.observe(window, 'load', fireContentLoadedEvent);
})(this);
Element.addMethods();
Hash.toQueryString = Object.toQueryString;
var Toggle = { display: Element.toggle };
Element.Methods.childOf = Element.Methods.descendantOf;
var Insertion = {
Before: function(element, content) {
return Element.insert(element, {before:content});},
Top: function(element, content) {
return Element.insert(element, {top:content});},
Bottom: function(element, content) {
return Element.insert(element, {bottom:content});},
After: function(element, content) {
return Element.insert(element, {after:content});}};
var $continue = new Error('"throw $continue" is deprecated, use "return" instead');
var Position = {
includeScrollOffsets: false,
prepare: function() {
this.deltaX =  window.pageXOffset
|| document.documentElement.scrollLeft
|| document.body.scrollLeft
|| 0;
this.deltaY =  window.pageYOffset
|| document.documentElement.scrollTop
|| document.body.scrollTop
|| 0;},
within: function(element, x, y) {
if (this.includeScrollOffsets)
return this.withinIncludingScrolloffsets(element, x, y);
this.xcomp = x;
this.ycomp = y;
this.offset = Element.cumulativeOffset(element);
return (y >= this.offset[1] &&
y <  this.offset[1] + element.offsetHeight &&
x >= this.offset[0] &&
x <  this.offset[0] + element.offsetWidth);},
withinIncludingScrolloffsets: function(element, x, y) {
var offsetcache = Element.cumulativeScrollOffset(element);
this.xcomp = x + offsetcache[0] - this.deltaX;
this.ycomp = y + offsetcache[1] - this.deltaY;
this.offset = Element.cumulativeOffset(element);
return (this.ycomp >= this.offset[1] &&
this.ycomp <  this.offset[1] + element.offsetHeight &&
this.xcomp >= this.offset[0] &&
this.xcomp <  this.offset[0] + element.offsetWidth);},
overlap: function(mode, element) {
if (!mode) return 0;
if (mode == 'vertical')
return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
element.offsetHeight;
if (mode == 'horizontal')
return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
element.offsetWidth;},
cumulativeOffset: Element.Methods.cumulativeOffset,
positionedOffset: Element.Methods.positionedOffset,
absolutize: function(element) {
Position.prepare();
return Element.absolutize(element);},
relativize: function(element) {
Position.prepare();
return Element.relativize(element);},
realOffset: Element.Methods.cumulativeScrollOffset,
offsetParent: Element.Methods.getOffsetParent,
page: Element.Methods.viewportOffset,
clone: function(source, target, options) {
options = options || { };
return Element.clonePosition(target, source, options);}};
if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
function iter(name) {
return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";}
instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
function(element, className) {
className = className.toString().strip();
var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
} : function(element, className) {
className = className.toString().strip();
var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
if (!classNames && !className) return elements;
var nodes = prototype$(element).getElementsByTagName('*');
className = ' ' + className + ' ';
for (var i = 0, child, cn; child = nodes[i]; i++) {
if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
(classNames && classNames.all(function(name) {
return !name.toString().blank() && cn.include(' ' + name + ' ');
}))))
elements.push(Element.extend(child));}
return elements;};
return function(className, parentElement) {
return prototype$(parentElement || document.body).getElementsByClassName(className);};
}(Element.Methods);
Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
initialize: function(element) {
this.element = prototype$(element);},
_each: function(iterator, context) {
this.element.className.split(/\s+/).select(function(name) {
return name.length > 0;
})._each(iterator, context);},
set: function(className) {
this.element.className = className;},
add: function(classNameToAdd) {
if (this.include(classNameToAdd)) return;
this.set($A(this).concat(classNameToAdd).join(' '));},
remove: function(classNameToRemove) {
if (!this.include(classNameToRemove)) return;
this.set($A(this).without(classNameToRemove).join(' '));},
toString: function() {
return $A(this).join(' ');}};
Object.extend(Element.ClassNames.prototype, Enumerable);
(function() {
window.Selector = Class.create({
initialize: function(expression) {
this.expression = expression.strip();},
findElements: function(rootElement) {
return Prototype.Selector.select(this.expression, rootElement);},
match: function(element) {
return Prototype.Selector.match(element, this.expression);},
toString: function() {
return this.expression;},
inspect: function() {
return "#<Selector: " + this.expression + ">";}});
Object.extend(Selector, {
matchElements: function(elements, expression) {
var match = Prototype.Selector.match,
results = [];
for (var i = 0, length = elements.length; i < length; i++) {
var element = elements[i];
if (match(element, expression)) {
results.push(Element.extend(element));}}
return results;},
findElement: function(elements, expression, index) {
index = index || 0;
var matchIndex = 0, element;
for (var i = 0, length = elements.length; i < length; i++) {
element = elements[i];
if (Prototype.Selector.match(element, expression) && index === matchIndex++) {
return Element.extend(element);}}},
findChildElements: function(element, expressions) {
var selector = expressions.toArray().join(', ');
return Prototype.Selector.select(selector, element || document);}});
})();
Hash.addMethods({
extend: function(values) {
Object.extend(this._object, values);}});
Hash.addMethods({
clean: function() {
this.each(function(pair){
if (pair.value === undefined || pair.value === null){
this.unset(pair.key);}
}.bind(this));}});
Array.prototype.extend = function(ary) {
ary.each(function(o,i){
this.push(o);
}.bind(this));};
Object.extend(Object, {
deepExtend: function(destination, source) {
com.liquidpixels.utilities.DeepMerge.extend(destination, source, {overrideArrays: true});},
deepClone: function(source, options) {
return com.liquidpixels.utilities.DeepMerge.clone(source, {overrideArrays: true});}});
Date.now = Date.now || function(){return +new Date;};


String.prototype.parseColor = function() {
var color = '#';
if (this.slice(0,4) == 'rgb(') {
var cols = this.slice(4,this.length-1).split(',');
var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);
} else {
if (this.slice(0,1) == '#') {
if (this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();
if (this.length==7) color = this.toLowerCase();}}
return (color.length==7 ? color : (arguments[0] || this));};
Element.collectTextNodes = function(element) {
return $A(prototype$(element).childNodes).collect( function(node) {
return (node.nodeType==3 ? node.nodeValue :
(node.hasChildNodes() ? Element.collectTextNodes(node) : ''));
}).flatten().join('');};
Element.collectTextNodesIgnoreClass = function(element, className) {
return $A(prototype$(element).childNodes).collect( function(node) {
return (node.nodeType==3 ? node.nodeValue :
((node.hasChildNodes() && !Element.hasClassName(node,className)) ?
Element.collectTextNodesIgnoreClass(node, className) : ''));
}).flatten().join('');};
Element.setContentZoom = function(element, percent) {
element = prototype$(element);
element.setStyle({fontSize: (percent/100) + 'em'});
if (Prototype.Browser.WebKit) window.scrollBy(0,0);
return element;};
Element.getInlineOpacity = function(element){
return prototype$(element).style.opacity || '';};
Element.forceRerendering = function(element) {
try {
element = prototype$(element);
var n = document.createTextNode(' ');
element.appendChild(n);
element.removeChild(n);
} catch(e) { }};
var Effect = {
_elementDoesNotExistError: {
name: 'ElementDoesNotExistError',
message: 'The specified DOM element does not exist, but is required for this effect to operate'},
Transitions: {
linear: Prototype.K,
sinoidal: function(pos) {
return (-Math.cos(pos*Math.PI)/2) + .5;},
reverse: function(pos) {
return 1-pos;},
flicker: function(pos) {
var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;
return pos > 1 ? 1 : pos;},
wobble: function(pos) {
return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;},
pulse: function(pos, pulses) {
return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;},
spring: function(pos) {
return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));},
none: function(pos) {
return 0;},
full: function(pos) {
return 1;}},
DefaultOptions: {
duration:   1.0,   // seconds
fps:        100,   // 100= assume 66fps max.
sync:       false, // true for combining
from:       0.0,
to:         1.0,
delay:      0.0,
queue:      'parallel'},
tagifyText: function(element) {
var tagifyStyle = 'position:relative';
if (Prototype.Browser.IE) tagifyStyle += ';zoom:1';
element = prototype$(element);
$A(element.childNodes).each( function(child) {
if (child.nodeType==3) {
child.nodeValue.toArray().each( function(character) {
element.insertBefore(
new Element('span', {style: tagifyStyle}).update(
character == ' ' ? String.fromCharCode(160) : character),
child);});
Element.remove(child);}});},
multiple: function(element, effect) {
var elements;
if (((typeof element == 'object') ||
Object.isFunction(element)) &&
(element.length))
elements = element;
else
elements = prototype$(element).childNodes;
var options = Object.extend({
speed: 0.1,
delay: 0.0
}, arguments[2] || { });
var masterDelay = options.delay;
$A(elements).each( function(element, index) {
new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));});},
PAIRS: {
'slide':  ['SlideDown','SlideUp'],
'blind':  ['BlindDown','BlindUp'],
'appear': ['Appear','Fade']},
toggle: function(element, effect, options) {
element = prototype$(element);
effect  = (effect || 'appear').toLowerCase();
return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({
queue: { position:'end', scope:(element.id || 'global'), limit: 1 }
}, options || {}));}};
Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;
Effect.ScopedQueue = Class.create(Enumerable, {
initialize: function() {
this.effects  = [];
this.interval = null;},
_each: function(iterator) {
this.effects._each(iterator);},
add: function(effect) {
var timestamp = new Date().getTime();
var position = Object.isString(effect.options.queue) ?
effect.options.queue : effect.options.queue.position;
switch(position) {
case 'front':
this.effects.findAll(function(e){ return e.state=='idle' }).each( function(e) {
e.startOn  += effect.finishOn;
e.finishOn += effect.finishOn;});
break;
case 'with-last':
timestamp = this.effects.pluck('startOn').max() || timestamp;
break;
case 'end':
timestamp = this.effects.pluck('finishOn').max() || timestamp;
break;}
effect.startOn  += timestamp;
effect.finishOn += timestamp;
if (!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))
this.effects.push(effect);
if (!this.interval)
this.interval = setInterval(this.loop.bind(this), 15);},
remove: function(effect) {
this.effects = this.effects.reject(function(e) { return e==effect });
if (this.effects.length == 0) {
clearInterval(this.interval);
this.interval = null;}},
loop: function() {
var timePos = new Date().getTime();
for(var i=0, len=this.effects.length;i<len;i++)
this.effects[i] && this.effects[i].loop(timePos);}});
Effect.Queues = {
instances: $H(),
get: function(queueName) {
if (!Object.isString(queueName)) return queueName;
return this.instances.get(queueName) ||
this.instances.set(queueName, new Effect.ScopedQueue());}};
Effect.Queue = Effect.Queues.get('global');
Effect.Base = Class.create({
position: null,
start: function(options) {
if (options && options.transition === false) options.transition = Effect.Transitions.linear;
this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });
this.currentFrame = 0;
this.state        = 'idle';
this.startOn      = this.options.delay*1000;
this.finishOn     = this.startOn+(this.options.duration*1000);
this.fromToDelta  = this.options.to-this.options.from;
this.totalTime    = this.finishOn-this.startOn;
this.totalFrames  = this.options.fps*this.options.duration;
this.render = (function() {
function dispatch(effect, eventName) {
if (effect.options[eventName + 'Internal'])
effect.options[eventName + 'Internal'](effect);
if (effect.options[eventName])
effect.options[eventName](effect);}
return function(pos) {
if (this.state === "idle") {
this.state = "running";
dispatch(this, 'beforeSetup');
if (this.setup) this.setup();
dispatch(this, 'afterSetup');}
if (this.state === "running") {
pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;
this.position = pos;
dispatch(this, 'beforeUpdate');
if (this.update) this.update(pos);
dispatch(this, 'afterUpdate');}};
})();
this.event('beforeStart');
if (!this.options.sync)
Effect.Queues.get(Object.isString(this.options.queue) ?
'global' : this.options.queue.scope).add(this);},
loop: function(timePos) {
if (timePos >= this.startOn) {
if (timePos >= this.finishOn) {
this.render(1.0);
this.cancel();
this.event('beforeFinish');
if (this.finish) this.finish();
this.event('afterFinish');
return;}
var pos   = (timePos - this.startOn) / this.totalTime,
frame = (pos * this.totalFrames).round();
if (frame > this.currentFrame) {
this.render(pos);
this.currentFrame = frame;}}},
cancel: function() {
if (!this.options.sync)
Effect.Queues.get(Object.isString(this.options.queue) ?
'global' : this.options.queue.scope).remove(this);
this.state = 'finished';},
event: function(eventName) {
if (this.options[eventName + 'Internal']) this.options[eventName + 'Internal'](this);
if (this.options[eventName]) this.options[eventName](this);},
inspect: function() {
var data = $H();
for(property in this)
if (!Object.isFunction(this[property])) data.set(property, this[property]);
return '#<Effect:' + data.inspect() + ',options:' + $H(this.options).inspect() + '>';}});
Effect.Parallel = Class.create(Effect.Base, {
initialize: function(effects) {
this.effects = effects || [];
this.start(arguments[1]);},
update: function(position) {
this.effects.invoke('render', position);},
finish: function(position) {
this.effects.each( function(effect) {
effect.render(1.0);
effect.cancel();
effect.event('beforeFinish');
if (effect.finish) effect.finish(position);
effect.event('afterFinish');});}});
Effect.Tween = Class.create(Effect.Base, {
initialize: function(object, from, to) {
object = Object.isString(object) ? prototype$(object) : object;
var args = $A(arguments), method = args.last(),
options = args.length == 5 ? args[3] : null;
this.method = Object.isFunction(method) ? method.bind(object) :
Object.isFunction(object[method]) ? object[method].bind(object) :
function(value) { object[method] = value };
this.start(Object.extend({ from: from, to: to }, options || { }));},
update: function(position) {
this.method(position);}});
Effect.Event = Class.create(Effect.Base, {
initialize: function() {
this.start(Object.extend({ duration: 0 }, arguments[0] || { }));},
update: Prototype.emptyFunction});
Effect.Opacity = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
this.element.setStyle({zoom: 1});
var options = Object.extend({
from: this.element.getOpacity() || 0.0,
to:   1.0
}, arguments[1] || { });
this.start(options);},
update: function(position) {
this.element.setOpacity(parseFloat(position));}});
Effect.Move = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
x:    0,
y:    0,
mode: 'relative'
}, arguments[1] || { });
this.start(options);},
setup: function() {
this.element.makePositioned();
this.originalLeft = parseFloat(this.element.getStyle('left') || '0');
this.originalTop  = parseFloat(this.element.getStyle('top')  || '0');
if (this.options.mode == 'absolute') {
this.options.x = this.options.x - this.originalLeft;
this.options.y = this.options.y - this.originalTop;}},
update: function(position) {
this.element.setStyle({
left: (this.options.x  * position + this.originalLeft).round() + 'px',
top:  (this.options.y  * position + this.originalTop).round()  + 'px'});}});
Effect.MoveBy = function(element, toTop, toLeft) {
return new Effect.Move(element,
Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));};
Effect.Scale = Class.create(Effect.Base, {
initialize: function(element, percent) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
scaleX: true,
scaleY: true,
scaleContent: true,
scaleFromCenter: false,
scaleMode: 'box',        // 'box' or 'contents' or { } with provided values
scaleFrom: 100.0,
scaleTo:   percent
}, arguments[2] || { });
this.start(options);},
setup: function() {
this.restoreAfterFinish = this.options.restoreAfterFinish || false;
this.elementPositioning = this.element.getStyle('position');
this.originalStyle = { };
['top','left','width','height','fontSize'].each( function(k) {
this.originalStyle[k] = this.element.style[k];
}.bind(this));
this.originalTop  = this.element.offsetTop;
this.originalLeft = this.element.offsetLeft;
var fontSize = this.element.getStyle('font-size') || '100%';
['em','px','%','pt'].each( function(fontSizeType) {
if (fontSize.indexOf(fontSizeType)>0) {
this.fontSize     = parseFloat(fontSize);
this.fontSizeType = fontSizeType;}
}.bind(this));
this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;
this.dims = null;
if (this.options.scaleMode=='box')
this.dims = [this.element.offsetHeight, this.element.offsetWidth];
if (/^content/.test(this.options.scaleMode))
this.dims = [this.element.scrollHeight, this.element.scrollWidth];
if (!this.dims)
this.dims = [this.options.scaleMode.originalHeight,
this.options.scaleMode.originalWidth];},
update: function(position) {
var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);
if (this.options.scaleContent && this.fontSize)
this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });
this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);},
finish: function(position) {
if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);},
setDimensions: function(height, width) {
var d = { };
if (this.options.scaleX) d.width = width.round() + 'px';
if (this.options.scaleY) d.height = height.round() + 'px';
if (this.options.scaleFromCenter) {
var topd  = (height - this.dims[0])/2;
var leftd = (width  - this.dims[1])/2;
if (this.elementPositioning == 'absolute') {
if (this.options.scaleY) d.top = this.originalTop-topd + 'px';
if (this.options.scaleX) d.left = this.originalLeft-leftd + 'px';
} else {
if (this.options.scaleY) d.top = -topd + 'px';
if (this.options.scaleX) d.left = -leftd + 'px';}}
this.element.setStyle(d);}});
Effect.Highlight = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({ startcolor: '#ffff99' }, arguments[1] || { });
this.start(options);},
setup: function() {
if (this.element.getStyle('display')=='none') { this.cancel(); return; }
this.oldStyle = { };
if (!this.options.keepBackgroundImage) {
this.oldStyle.backgroundImage = this.element.getStyle('background-image');
this.element.setStyle({backgroundImage: 'none'});}
if (!this.options.endcolor)
this.options.endcolor = this.element.getStyle('background-color').parseColor('#ffffff');
if (!this.options.restorecolor)
this.options.restorecolor = this.element.getStyle('background-color');
this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));
this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));},
update: function(position) {
this.element.setStyle({backgroundColor: $R(0,2).inject('#',function(m,v,i){
return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });},
finish: function() {
this.element.setStyle(Object.extend(this.oldStyle, {
backgroundColor: this.options.restorecolor
}));}});
Effect.ScrollTo = function(element) {
var options = arguments[1] || { },
scrollOffsets = document.viewport.getScrollOffsets(),
elementOffsets = prototype$(element).cumulativeOffset();
if (options.offset) elementOffsets[1] += options.offset;
return new Effect.Tween(null,
scrollOffsets.top,
elementOffsets[1],
options,
function(p){ scrollTo(scrollOffsets.left, p.round()); }
);};
Effect.Fade = function(element) {
element = prototype$(element);
var oldOpacity = element.getInlineOpacity();
var options = Object.extend({
from: element.getOpacity() || 1.0,
to:   0.0,
afterFinishInternal: function(effect) {
if (effect.options.to!=0) return;
effect.element.hide().setStyle({opacity: oldOpacity});}
}, arguments[1] || { });
return new Effect.Opacity(element,options);};
Effect.Appear = function(element) {
element = prototype$(element);
var options = Object.extend({
from: (element.getStyle('display') == 'none' ? 0.0 : element.getOpacity() || 0.0),
to:   1.0,
afterFinishInternal: function(effect) {
effect.element.forceRerendering();},
beforeSetup: function(effect) {
effect.element.setOpacity(effect.options.from).show();
}}, arguments[1] || { });
return new Effect.Opacity(element,options);};
Effect.Puff = function(element) {
element = prototype$(element);
var oldStyle = {
opacity: element.getInlineOpacity(),
position: element.getStyle('position'),
top:  element.style.top,
left: element.style.left,
width: element.style.width,
height: element.style.height};
return new Effect.Parallel(
[ new Effect.Scale(element, 200,
{ sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),
new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],
Object.extend({ duration: 1.0,
beforeSetupInternal: function(effect) {
Position.absolutize(effect.effects[0].element);},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().setStyle(oldStyle); }
}, arguments[1] || { })
);};
Effect.BlindUp = function(element) {
element = prototype$(element);
element.makeClipping();
return new Effect.Scale(element, 0,
Object.extend({ scaleContent: false,
scaleX: false,
restoreAfterFinish: true,
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping();}
}, arguments[1] || { })
);};
Effect.BlindDown = function(element) {
element = prototype$(element);
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, 100, Object.extend({
scaleContent: false,
scaleX: false,
scaleFrom: 0,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makeClipping().setStyle({height: '0px'}).show();},
afterFinishInternal: function(effect) {
effect.element.undoClipping();}
}, arguments[1] || { }));};
Effect.SwitchOff = function(element) {
element = prototype$(element);
var oldOpacity = element.getInlineOpacity();
return new Effect.Appear(element, Object.extend({
duration: 0.4,
from: 0,
transition: Effect.Transitions.flicker,
afterFinishInternal: function(effect) {
new Effect.Scale(effect.element, 1, {
duration: 0.3, scaleFromCenter: true,
scaleX: false, scaleContent: false, restoreAfterFinish: true,
beforeSetup: function(effect) {
effect.element.makePositioned().makeClipping();},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().undoPositioned().setStyle({opacity: oldOpacity});}});}
}, arguments[1] || { }));};
Effect.DropOut = function(element) {
element = prototype$(element);
var oldStyle = {
top: element.getStyle('top'),
left: element.getStyle('left'),
opacity: element.getInlineOpacity() };
return new Effect.Parallel(
[ new Effect.Move(element, {x: 0, y: 100, sync: true }),
new Effect.Opacity(element, { sync: true, to: 0.0 }) ],
Object.extend(
{ duration: 0.5,
beforeSetup: function(effect) {
effect.effects[0].element.makePositioned();},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);}
}, arguments[1] || { }));};
Effect.Shake = function(element) {
element = prototype$(element);
var options = Object.extend({
distance: 20,
duration: 0.5
}, arguments[1] || {});
var distance = parseFloat(options.distance);
var split = parseFloat(options.duration) / 10.0;
var oldStyle = {
top: element.getStyle('top'),
left: element.getStyle('left') };
return new Effect.Move(element,
{ x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
new Effect.Move(effect.element,
{ x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {
effect.element.undoPositioned().setStyle(oldStyle);
}}); }}); }}); }}); }}); }});};
Effect.SlideDown = function(element) {
element = prototype$(element).cleanWhitespace();
var oldInnerBottom = element.down().getStyle('bottom');
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, 100, Object.extend({
scaleContent: false,
scaleX: false,
scaleFrom: window.opera ? 0 : 1,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makePositioned();
effect.element.down().makePositioned();
if (window.opera) effect.element.setStyle({top: ''});
effect.element.makeClipping().setStyle({height: '0px'}).show();},
afterUpdateInternal: function(effect) {
effect.element.down().setStyle({bottom:
(effect.dims[0] - effect.element.clientHeight) + 'px' });},
afterFinishInternal: function(effect) {
effect.element.undoClipping().undoPositioned();
effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom}); }
}, arguments[1] || { })
);};
Effect.SlideUp = function(element) {
element = prototype$(element).cleanWhitespace();
var oldInnerBottom = element.down().getStyle('bottom');
var elementDimensions = element.getDimensions();
return new Effect.Scale(element, window.opera ? 0 : 1,
Object.extend({ scaleContent: false,
scaleX: false,
scaleMode: 'box',
scaleFrom: 100,
scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
restoreAfterFinish: true,
afterSetup: function(effect) {
effect.element.makePositioned();
effect.element.down().makePositioned();
if (window.opera) effect.element.setStyle({top: ''});
effect.element.makeClipping().show();},
afterUpdateInternal: function(effect) {
effect.element.down().setStyle({bottom:
(effect.dims[0] - effect.element.clientHeight) + 'px' });},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().undoPositioned();
effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom});}
}, arguments[1] || { })
);};
Effect.Squish = function(element) {
return new Effect.Scale(element, window.opera ? 1 : 0, {
restoreAfterFinish: true,
beforeSetup: function(effect) {
effect.element.makeClipping();},
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping();}});};
Effect.Grow = function(element) {
element = prototype$(element);
var options = Object.extend({
direction: 'center',
moveTransition: Effect.Transitions.sinoidal,
scaleTransition: Effect.Transitions.sinoidal,
opacityTransition: Effect.Transitions.full
}, arguments[1] || { });
var oldStyle = {
top: element.style.top,
left: element.style.left,
height: element.style.height,
width: element.style.width,
opacity: element.getInlineOpacity() };
var dims = element.getDimensions();
var initialMoveX, initialMoveY;
var moveX, moveY;
switch (options.direction) {
case 'top-left':
initialMoveX = initialMoveY = moveX = moveY = 0;
break;
case 'top-right':
initialMoveX = dims.width;
initialMoveY = moveY = 0;
moveX = -dims.width;
break;
case 'bottom-left':
initialMoveX = moveX = 0;
initialMoveY = dims.height;
moveY = -dims.height;
break;
case 'bottom-right':
initialMoveX = dims.width;
initialMoveY = dims.height;
moveX = -dims.width;
moveY = -dims.height;
break;
case 'center':
initialMoveX = dims.width / 2;
initialMoveY = dims.height / 2;
moveX = -dims.width / 2;
moveY = -dims.height / 2;
break;}
return new Effect.Move(element, {
x: initialMoveX,
y: initialMoveY,
duration: 0.01,
beforeSetup: function(effect) {
effect.element.hide().makeClipping().makePositioned();},
afterFinishInternal: function(effect) {
new Effect.Parallel(
[ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),
new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),
new Effect.Scale(effect.element, 100, {
scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})
], Object.extend({
beforeSetup: function(effect) {
effect.effects[0].element.setStyle({height: '0px'}).show();},
afterFinishInternal: function(effect) {
effect.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);}
}, options)
);}});};
Effect.Shrink = function(element) {
element = prototype$(element);
var options = Object.extend({
direction: 'center',
moveTransition: Effect.Transitions.sinoidal,
scaleTransition: Effect.Transitions.sinoidal,
opacityTransition: Effect.Transitions.none
}, arguments[1] || { });
var oldStyle = {
top: element.style.top,
left: element.style.left,
height: element.style.height,
width: element.style.width,
opacity: element.getInlineOpacity() };
var dims = element.getDimensions();
var moveX, moveY;
switch (options.direction) {
case 'top-left':
moveX = moveY = 0;
break;
case 'top-right':
moveX = dims.width;
moveY = 0;
break;
case 'bottom-left':
moveX = 0;
moveY = dims.height;
break;
case 'bottom-right':
moveX = dims.width;
moveY = dims.height;
break;
case 'center':
moveX = dims.width / 2;
moveY = dims.height / 2;
break;}
return new Effect.Parallel(
[ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),
new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),
new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })
], Object.extend({
beforeStartInternal: function(effect) {
effect.effects[0].element.makePositioned().makeClipping();},
afterFinishInternal: function(effect) {
effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle); }
}, options)
);};
Effect.Pulsate = function(element) {
element = prototype$(element);
var options    = arguments[1] || { },
oldOpacity = element.getInlineOpacity(),
transition = options.transition || Effect.Transitions.linear,
reverser   = function(pos){
return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);};
return new Effect.Opacity(element,
Object.extend(Object.extend({  duration: 2.0, from: 0,
afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }
}, options), {transition: reverser}));};
Effect.Fold = function(element) {
element = prototype$(element);
var oldStyle = {
top: element.style.top,
left: element.style.left,
width: element.style.width,
height: element.style.height };
element.makeClipping();
return new Effect.Scale(element, 5, Object.extend({
scaleContent: false,
scaleX: false,
afterFinishInternal: function(effect) {
new Effect.Scale(element, 1, {
scaleContent: false,
scaleY: false,
afterFinishInternal: function(effect) {
effect.element.hide().undoClipping().setStyle(oldStyle);
} });
}}, arguments[1] || { }));};
Effect.Morph = Class.create(Effect.Base, {
initialize: function(element) {
this.element = prototype$(element);
if (!this.element) throw(Effect._elementDoesNotExistError);
var options = Object.extend({
style: { }
}, arguments[1] || { });
if (!Object.isString(options.style)) this.style = $H(options.style);
else {
if (options.style.include(':'))
this.style = options.style.parseStyle();
else {
this.element.addClassName(options.style);
this.style = $H(this.element.getStyles());
this.element.removeClassName(options.style);
var css = this.element.getStyles();
this.style = this.style.reject(function(style) {
return style.value == css[style.key];});
options.afterFinishInternal = function(effect) {
effect.element.addClassName(effect.options.style);
effect.transforms.each(function(transform) {
effect.element.style[transform.style] = '';});};}}
this.start(options);},
setup: function(){
function parseColor(color){
if (!color || ['rgba(0, 0, 0, 0)','transparent'].include(color)) color = '#ffffff';
color = color.parseColor();
return $R(0,2).map(function(i){
return parseInt( color.slice(i*2+1,i*2+3), 16 );});}
this.transforms = this.style.map(function(pair){
var property = pair[0], value = pair[1], unit = null;
if (value.parseColor('#zzzzzz') != '#zzzzzz') {
value = value.parseColor();
unit  = 'color';
} else if (property == 'opacity') {
value = parseFloat(value);
if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
this.element.setStyle({zoom: 1});
} else if (Element.CSS_LENGTH.test(value)) {
var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
value = parseFloat(components[1]);
unit = (components.length == 3) ? components[2] : null;}
var originalValue = this.element.getStyle(property);
return {
style: property.camelize(),
originalValue: unit=='color' ? parseColor(originalValue) : parseFloat(originalValue || 0),
targetValue: unit=='color' ? parseColor(value) : value,
unit: unit};
}.bind(this)).reject(function(transform){
return (
(transform.originalValue == transform.targetValue) ||
(
transform.unit != 'color' &&
(isNaN(transform.originalValue) || isNaN(transform.targetValue))
)
);});},
update: function(position) {
var style = { }, transform, i = this.transforms.length;
while(i--)
style[(transform = this.transforms[i]).style] =
transform.unit=='color' ? '#'+
(Math.round(transform.originalValue[0]+
(transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +
(Math.round(transform.originalValue[1]+
(transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +
(Math.round(transform.originalValue[2]+
(transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :
(transform.originalValue +
(transform.targetValue - transform.originalValue) * position).toFixed(3) +
(transform.unit === null ? '' : transform.unit);
this.element.setStyle(style, true);}});
Effect.Transform = Class.create({
initialize: function(tracks){
this.tracks  = [];
this.options = arguments[1] || { };
this.addTracks(tracks);},
addTracks: function(tracks){
tracks.each(function(track){
track = $H(track);
var data = track.values().first();
this.tracks.push($H({
ids:     track.keys().first(),
effect:  Effect.Morph,
options: { style: data }
}));
}.bind(this));
return this;},
play: function(){
return new Effect.Parallel(
this.tracks.map(function(track){
var ids = track.get('ids'), effect = track.get('effect'), options = track.get('options');
var elements = [prototype$(ids) || $$(ids)].flatten();
return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });
}).flatten(),
this.options
);}});
Element.CSS_PROPERTIES = $w(
'backgroundColor backgroundPosition borderBottomColor borderBottomStyle ' +
'borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth ' +
'borderRightColor borderRightStyle borderRightWidth borderSpacing ' +
'borderTopColor borderTopStyle borderTopWidth bottom clip color ' +
'fontSize fontWeight height left letterSpacing lineHeight ' +
'marginBottom marginLeft marginRight marginTop markerOffset maxHeight '+
'maxWidth minHeight minWidth opacity outlineColor outlineOffset ' +
'outlineWidth paddingBottom paddingLeft paddingRight paddingTop ' +
'right textIndent top width wordSpacing zIndex');
Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;
String.__parseStyleElement = document.createElement('div');
String.prototype.parseStyle = function(){
var style, styleRules = $H();
if (Prototype.Browser.WebKit)
style = new Element('div',{style:this}).style;
else {
String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
style = String.__parseStyleElement.childNodes[0].style;}
Element.CSS_PROPERTIES.each(function(property){
if (style[property]) styleRules.set(property, style[property]);});
if (Prototype.Browser.IE && this.include('opacity'))
styleRules.set('opacity', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);
return styleRules;};
if (document.defaultView && document.defaultView.getComputedStyle) {
Element.getStyles = function(element) {
var css = document.defaultView.getComputedStyle(prototype$(element), null);
return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {
styles[property] = css[property];
return styles;});};
} else {
Element.getStyles = function(element) {
element = prototype$(element);
var css = element.currentStyle, styles;
styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {
results[property] = css[property];
return results;});
if (!styles.opacity) styles.opacity = element.getOpacity();
return styles;};}
Effect.Methods = {
morph: function(element, style) {
element = prototype$(element);
new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));
return element;},
visualEffect: function(element, effect, options) {
element = prototype$(element);
var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
new Effect[klass](element, options);
return element;},
highlight: function(element, options) {
element = prototype$(element);
new Effect.Highlight(element, options);
return element;}};
$w('fade appear grow shrink fold blindUp blindDown slideUp slideDown '+
'pulsate shake puff squish switchOff dropOut').each(
function(effect) {
Effect.Methods[effect] = function(element, options){
element = prototype$(element);
Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);
return element;};}
);
$w('getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles').each(
function(f) { Effect.Methods[f] = Element[f]; }
);
Element.addMethods(Effect.Methods);

if(typeof com.liquidpixels.event === 'undefined') {
com.liquidpixels.event = {};}
com.liquidpixels.utilities.isNaN = function(o) {
if(!o && typeof(o) == "number" && o !== 0) {
return true;
} else {
return false;}};
var $ISNAN = com.liquidpixels.utilities.isNaN;
com.liquidpixels.utilities.isTrue = function(o) {
if(o) {
if(o.toLowerCase) {
var x = o.toLowerCase();
if(x == "no" || x == "false" || x == "0") { return false; }}
return true;}
return false;};
var $ISTRUE = com.liquidpixels.utilities.isTrue;
com.liquidpixels.utilities.objTrue = function(o) {
if(o) {
if(Object.isArray(o)) {
return !!(o.length);
} else if(Object.isHash(o)) {
return !!(o.keys().length);
} else if(typeof(o) === "object") {
return !!(keys(o).length);}
return true;}
return false;};
var $OBJTRUE = com.liquidpixels.utilities.objTrue;
com.liquidpixels.utilities.isDefined = function(a) {
if(typeof(a) == "undefined" || a === null || $ISNAN(a)) {
return false;
} else {
return true;}};
var $DEF = com.liquidpixels.utilities.isDefined;
var $DEFINED = com.liquidpixels.utilities.isDefined;
com.liquidpixels.utilities.ifNullReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
if($DEF(arguments[i])) {
return arguments[i];}}
return arguments[len - 1];};
var $NVL = com.liquidpixels.utilities.ifNullReplace;
com.liquidpixels.utilities.ifNullOrEmptyReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
var arg = arguments[i];
if($DEF(arg) && arg !== "") {
return arg;}}
return arguments[len - 1];};
var $NZS = com.liquidpixels.utilities.ifNullOrEmptyReplace;
com.liquidpixels.utilities.ifNullOrFalseReplace = function(a) {
var len = arguments.length;
for(var i=0; i<len; i++) {
var arg = arguments[i];
if(arg && $DEF(arg)) {
return arg;}}
return arguments[len - 1];};
var $NFV = com.liquidpixels.utilities.ifNullOrFalseReplace;

com.liquidpixels.Mixable = Class.create( {
options:		undefined, // {}
mixName:		undefined, // {}
target:			undefined, //
exports:		undefined, // array of items to export
overrides:		undefined, // array of items to
initialize: function(options) {
this.options = {};
this.setDefaults();
this.exports = [];
this.overrides = [];
this.prepareExportList();
this.prepareOverridesList();
Object.extend(this.options, options);
if(this.options.mixOpts.setOverrides) {
this.overrides = this.options.mixOpts.setOverrides;}
if(this.options.mixOpts.addOverrides) {
this.overrides.push(this.options.mixOpts.addOverrides);
this.overrides = this.overrides.flatten();}
if(this.options.mixOpts.remOverrides) {
var ovs = this.overrides;
(this.options.mixOpts.remOverrides).each(function(o, i) {
ovs = ovs.without(o);});
this.overrides = ovs;}
if(!this.target) {
this.target = this.options.target || this.options.mixOpts.mixObject;}},
setDefaults: function() { /* VIRTUAL */ },
prepareEvents: function() { /* VIRTUAL */ },
prepare: function() {/* VIRTUAL */ },
clearEvents: function() { /* VIRTUAL */ },
clearEvent: function(eventName) { /* VIRTUAL */ },
prepareExportList: function(list) {
this.addToExportList(['options', 'target', 'mixName', 'exports',
'overrides', 'prepare', 'prepareEvents',
'clearEvents', 'clearEvent',
'toString', 'DESTROY']);
if(list) {
this.addToExportList(list);}},
addToExportList: function(list){
if(list) {
$A(list).each(function(o,i) {
this.exports.push(o);
}.bind(this));}},
getExportList: function() { return this.exports; },
prepareOverridesList: function(list) {
if(list) {
this.addToOverridesList(list);}},
addToOverridesList: function(list) {
if(list) {
$A(list).each(function(o,i) {
this.overrides.push(o);
}.bind(this));}},
getOverrideList: function() { return this.overrides; },
toString: function() { return "com.liquidpixels.Mixable"; },
DESTROY: function() {
this.clearEvents();
this.options = null;}});
com.liquidpixels.Mixable.applyTo = function(object, mixClass, options) {
if(!object) { return false; }
var _Mixer, mixer, mixName, mixOptions;
if(mixClass) {
var mcType = typeof(mixClass);
if(mcType == "function") {
mixer   = mixClass;
mixOptions = options || {};
} else if(mcType == "object") {
mixer = mixClass.mixOpts.mixClass;
mixOptions = mixClass;}
} else {
if(!options) {return false};
mixer   = options.mixOpts.mixClass;
mixOptions = options;}
if(!mixOptions.mixOpts) { mixOptions.mixOpts = {}; }
if(mixer) {
mixOptions.mixOpts.mixObject = object;
_Mixer = new mixer(mixOptions);
mixName = mixOptions.mixOpts.mixName || _Mixer.mixName || mixer.toString();
mixName.replace(/\./g, '_');
if(typeof object[mixName] !== 'undefined') { return false; }
object[mixName] = {};
} else {
_Mixer = new com.liquidpixels.Mixable(mixOptions);
object.Mixable = {};
return false;}
var classExports = _Mixer.getExportList();
if(classExports) {
if(classExports.constructor === Array) {
$A(classExports).each(function(o, i) {
if(_Mixer[o] !== null) {
object[mixName][o] = _Mixer[o];}});
} else {
$H(classExports).each(function(p) {
if(_Mixer[o] !== null) {
object[mixName][p.key] = _Mixer[p.value];}});}}
var classOverrides = _Mixer.getOverrideList();
if(classOverrides) {
if(classOverrides.constructor === Array) {
$A(classOverrides).each(function(o, i) {
if(_Mixer[o] !== null) {
object[o] = _Mixer[o];}});
} else {
$H(classOverrides).each(function(p) {
if(_Mixer[o] !== null) {
object[p.key] = _Mixer[p.value];}});}}
var _MixerName = _Mixer.toString() || _Mixer.mixName || mixOptions.mixOpts.mixName;
object[mixName]._MixClassName = _MixerName;
return true;};


com.liquidpixels.Basic = Class.create( {
parent:     undefined,
options:    undefined,
initialize: function(parent, options) {
this.parent = parent;
if( !this.options ) { this.options = {}; }
this.setDefaults();
this.initializeSpecific();
this.optionsExtend(options);},
optionsExtend: function(options) {
Object.deepExtend(this.options, options);},
setDefaults: function() {/* VIRTUAL */ },
initializeSpecific: function() {/* VIRTUAL */ },
DESTROY: function() {
this.parent = null;
this.options = null;},
toString: function() { return 'com.liquidpixels.Basic'; }});
com.liquidpixels.utilities.typeOf = function(thing) {
var instList = com.liquidpixels.utilities.Type.INSTOF;
if(thing == undefined) {
return "Undefined"}
var rtn;
var backupCheck;
var constrBy = "Unknown";
try{
if (thing.constructor.toString().match(/function\s*([^\(]*)/)){
backupCheck = thing.constructor.toString().match(/function\s*([^\(]*)/)[1];
}else if (thing.constructor.toString().match(/\[object\s*([^\]]*)]/)){
backupCheck = thing.constructor.toString().match(/\[object\s*([^\]]*)]/)[1];}
constrBy = thing.constructor.name || backupCheck || "Unknown";
}catch(e){}
if(constrBy == 'Number') {
rtn = (isNaN(thing) ? "NaN" : "Number");
} else if(thing instanceof Hash) {
rtn = "Hash";
} else if(constrBy == 'klass') {
rtn = 'KlassInstance';
} else if(constrBy == 'Function') {
if(thing.name && thing.name == 'klass') {
rtn = 'Klass';
} else {
rtn = 'Function';}}
rtn = rtn || constrBy;
return rtn;};
com.liquidpixels.Exception = Class.create( {
type: 					'Exception',		// static, final
target:					undefined,
severity:				'warning',
e:						undefined,
message:				undefined,
fileName:				undefined,
lineNumber:				undefined,
exceptionClass:			undefined,
initialize: function(e) {
if(e) {
this.e = e;
this.target 		  = e.target;
this.severity 		  = e.severity;
this.lineNumber 	  = e.lineNumber;
this.message 		  = e.message;
this.fileName 		  = e.fileName;
this.execeptionClass  = e.exceptionClass;};},
toString: function() {
return this.type + ": " + this.message + "\n" +
(this.fileName ? this.fileName + ":" : "") + (this.lineNumber || "");}});
com.liquidpixels.event.Event = Class.create( {
type:			'Event',		// static, final
target:			undefined,		// Eventee
UAevent:		undefined,		// Browser's Event object
options:		undefined,
initialize: function(options) {
this.options = {};
Object.extend(this.options, options);
if(this.options.target) { this.target = this.options.target }
if(this.options.UAevent) { this.UAevent = this.options.UAevent }},
typeize: function(type) { this.type = this.type + "." + type },
toString: function() { return this.type; }});
com.liquidpixels.event.TypedEvent = Class.create(com.liquidpixels.event.Event, {
initialize: function($super, type, options) {
$super(options);
this.typeize(type);}});
com.liquidpixels.liquifire.LiquiFire = Class.create( {
server:			undefined,
uri:			undefined,
port:			undefined,
valid:			undefined,
revision: "$Revision: 7156 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
initialize: function(server, uri, port, options) {
this.options = {};
this.setDefaults();
Object.extend(this.options, options);
this.setServer(server);
this.setURI(uri);
this.setPort(port);},
setDefaults: function(){
Object.extend(this.options, {
alwaysUseSSL: false,
neverUseSSL: false});},
getServer: function() {
return this.server || "";},
setServer: function(s) {
this.server = s || "";},
getURI: function() {
return this.uri || "";},
setURI: function(u) {
this.uri = u || "";},
getPort: function() {
return this.port || "";},
setPort: function(p) {
var pstr = p + "";
pstr === '80' ? this.port = "" : this.port = p;},
getZapDir: function() {
return this.httpProtocalCheck() + '//' + this.getServer() + this.getPortAsString() + '/zap';
},
validate: function() {
if(this.server && this.uri) {
this.valid = true;
} else {
this.valid = false;}},
isValid: function() {
this.validate();
return this.valid;},
getPortAsString: function() {
if(this.port && this.port != 80) {
return ":" + this.port;
} else {
return "";}},
escape: function(v) {
v = v.replace(/\'/g, 'U2019');
v = v.replace(/&/g, 'U0026amp;');
v = v.replace(/[\-][\-]/g, 'U2014');
v = v.replace(/\(/g, 'U0026lp;');
v = v.replace(/\)/g, 'U0026rp;');
return v;},
toURL: function() {
return this.httpProtocalCheck() + '//' + this.getServer() + this.getPortAsString() +
'/' + this.getURI();},
asURL: function() { return this.toURL(); },
toString: function() {
var s = "[LiquiFire Connection] ";
if(this.isValid()) {
s += this.getServer();
s += this.getPortAsString();
s += "/" + this.getURI();
} else {
s += "(invalid connection!)";}
return s;},
toQueryString: function() {
var port = this.getPort();
var str = "server=" + this.getServer() +
"&uri=" + this.getURI() +
(port ? "&port=" + port : "");
return str;},
httpProtocalCheck: function(){
var protocal = window.location.protocol;
if (this.options.alwaysUseSSL){
protocal = "https:";}
if (this.options.neverUseSSL){
protocal = "http:"}
return protocal;}});
com.liquidpixels.liquifire.Command = Class.create( {
revision: "$Revision: 6649 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
name:		undefined,
atts:		undefined,
keys:		undefined,
options:	undefined,
initialize: function(name, atts, options) {
this.name = name;
this.atts = {};
this.keys = new Array();
if( !this.options ) { this.options = {sortAttribs: true}; }
Object.extend(this.options, options);
if(atts) {
Object.extend(this.atts, atts);
$H(this.atts).each(function(pair) {
this.keys.push(pair.key);
}.bind(this));
if (this.options.sortAttribs) {
this.keys.sort();}}},
clone: function() {
var to = new com.liquidpixels.liquifire.Command(this.name, this.atts);
return to;},
asString: function() {
var i;
var c = "" + this.name + '=';
var atts = this.atts;
var katts = this.keys;
var len = katts.length;
for(var i=0; i < len; ++i ) {
var key = katts[i];
c +=  key + '[' + atts[key] + '],';};
return c.substring(0, c.length - 1);},
asHtml: function() {
var c = '<span class="lfcommand">';
var atts = this.atts;
var katts = this.keys;
var len = katts.length;
if(this.name.match(/^#/)) {
c += '<span class="comment">' + this.name;
c += '=';
for(var i=0; i < len; ++i ) {
var key = katts[i];
c +=  key + '[' + atts[key] + '],';};
c = c.substring(0, c.length);
c = c.replace(/=$/, "");
} else {
c += '<span class="name">' + this.name + '</span>';
c += '<span class="op">=</span>';
for(var i=0; i < len; ++i ) {
var key = katts[i];
var value = String(atts[key]);
if(value) {
value = value.replace(/</g, "&lt;");
value = value.replace(/>/g, "&gt;");}
c += '<span class="argName">' + key + '</span>';
c += '<span class="op">[</span>';
c += '<span class="argValue">' + value + '</span>';
c += '<span class="op">],</span>';};
c = c.substring(0, c.length - 8);}
c += "</span></span>";
return c;},
get: function(key) {
return this.atts[key];},
getAtt: function(key) { return this.get(key); },
set: function(key, value) {
if(!$DEF(this.atts[key])) {
this.keys.push(key);
if (this.options.sortAttribs) {
this.keys.sort();}}
this.atts[key] = value;},
addAtt: function(key, value) { this.set(key, value); },
setAtt: function(key, value) { this.set(key, value); },
removeAtt: function(key) {
this.atts[key] = null;
this.keys = this.keys.without(key);},
getName: function() {
return this.name;},
setName: function(newName) {
this.name = newName;},
attributes: function(key) {
return this.atts;},
parse2: function(s) {
var state = 'name';
this.name = '';
this.atts = {};
var k = '';
var v = '';
var l = s.length;
for(var i=0; i<l; i++) {
var c = s.substring(i, i+1);
var c1 = s.substring(i+1, i+2);
switch(state) {
case 'name':
if(c == '=') {
state = 'key';
break;}
this.name += c;
break;
case 'key':
if(c == '[') {
state = 'val';
break;}
k += c;
break;
case 'val':
if( ((c == ']') && (c1 == ',')) || ((c == ']') && (c1 == '')) ) {
this.set(k, v);
state = 'haveatt';
break;}
v += c;
break;
case 'haveatt':
k = '';
v = '';
if(c == ',')
state = 'key';
break;}}},
parse: function(s) {
this.name = '';
this.atts = {};
var parts = s.split('=');
if(parts[0]) {
this.name = parts.shift();}
if(parts[0]) {
var args = parts.join('=').split('],');
var l = args.length;
for(var i = 0; i < l; i++) {
arg = args[i];
var argParts = arg.match(/^([^\[]*)(.*)/);
if(argParts) {
if(argParts[2].charAt(0) == '[') {
argParts[2] = argParts[2].substr(1);}
if(argParts[2].charAt(argParts[2].length - 1) == ']') {
argParts[2] = argParts[2].substr(0, argParts[2].length - 1);}
if (argParts[1]){
this.set(argParts[1], argParts[2]);}}}}},
sortKeys: function() {
this.keys.sort();}});
com.liquidpixels.liquifire.Chain = Class.create( {
revision: "$Revision: 5739 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
lf:			undefined,
commands:	undefined,
initialize: function(server, uri, port, options) {
if(typeof(server) == 'object') {
this.setLiquiFire(server);
} else {
var lf = new com.liquidpixels.liquifire.LiquiFire(server, uri, port, options);
this.setLiquiFire(lf);}
this.commands = new Array();},
clone: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
$A(this.commands).each(function(o,i) {
to.commands[i] = o.clone();});
return to;},
shallowClone: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
Object.extend(to.commands, this.commands);
return to;},
cloneFromString: function() {
var to = new com.liquidpixels.liquifire.Chain(this.lf);
to.parse(this.asString());
return to;},
setLiquiFire: function(lfc) {
if(lfc.isValid()) { this.lf = lfc; }},
getLiquiFire: function() {
return this.lf;},
setServer: function(s) {
this.lf.setServer(s);},
getServer: function() {
if(this.lf) { return this.lf.getServer(); }
return "";},
setPort: function(n) {
if(this.lf) { this.lf.setPort(n); }},
getPort: function() {
if(this.lf) { return this.lf.getPort(); }
return "";},
setURI: function(u) {
if(this.lf) { this.lf.setURI(u); }},
getURI: function() {
if(this.lf) { return this.lf.getURI(); }
return "";},
addCommand: function(command, args) {
var cmd;
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, args);}
var pos = this.commands.length;
this.commands.push(cmd);
return pos;},
addSink: function(args) {
this.addCommand("sink", args);},
insertCommand: function(position, command, args) {
var cmd, pos;
if(Object.isString(position)) {
pos = this.findCommand(position) || this.length();
} else {
pos = position;}
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, args);}
if(!pos && pos != 0) {return null;}
this.commands.splice(pos, 0, cmd);
return pos;},
hasCommand: function(name, count) {
var pos = this.findCommand(name, count);
return ($DEF(pos) ? true : false);},
deleteCommand: function(pos) {
if($DEF(pos)) { this.commands.splice(pos, 1); }},
getCommand: function(pos) {
return this.commands[pos];},
getCommandByName: function(name, count) {
var pos = this.findCommand(name, count);
if($DEF(pos)) {
return this.getCommand(pos);
} else {
return null;}},
findCommand: function(name, count) {
var c = 0;
if(!count && count != 0) { count = -1 }
for(var i=0; i<this.commands.length; i++) {
if(this.commands[i].getName() == name) {
if(++c > count) {
return i;}}}
return null;},
getCommands: function() {
return this.commands;},
setCommand: function(pos, command, opts) {
var cmd;
if(typeof(command) == "object") {
cmd = command;
} else {
cmd = new com.liquidpixels.liquifire.Command(command, opts);}
this.commands[pos] = cmd;},
numCommands: function() {
return this.commands.length;},
length: function() {
return this.commands.length;},
asString: function() {
var i;
var chain = '';
for(i=0; i<this.commands.length; i++) {
chain += this.commands[i].asString() + '&';}
return chain.substring(0, chain.length -1);},
asURL: function() {
var chain = this.asURLVariable();
if(this.lf && this.lf.isValid()) {
return this.lf.toURL() + '?' + chain;
} else {
return "";}},
asURLVariable: function() {
var s = this.asString();
var chain = encodeURI(s);
chain = chain.replace(/\+/g,"%2B");
chain = chain.replace(/#/g,"%23");
return chain;},
parse: function(s) {
this.commands = new Array();
this._parseString(s);},
parseAdd: function(s) {
this._parseString(s);},
_parseString: function(s) {
var cStrings = s.split('&');
for(var i = 0; i < cStrings.length; i++) {
var c = new com.liquidpixels.liquifire.Command();
c.parse(cStrings[i]);
this.addCommand(c);}},
applyTransform: function(t) {
t.applyToChain(this);},
toString: function() { return "com.liquidpixels.liquifire.Chain" }});
com.liquidpixels.magnify.Magnify = Class.create( {
setImage: function(image) {
if (image && image.toString && image.toString() == "com.liquidpixels.liquifire.Chain"){
this.loadChain(image);
}else{
this.loadImage(image);}},
loadChain: function(chain) {
this.DESTROY();
var options = Object.deepClone(this.originalOptions);
options.view.chain = chain;
options.view.image = undefined;
this.apiCall = "loadChain";
this.initialize(this.parent, options);},
loadImage: function(image) {
this.DESTROY();
var options = Object.deepClone(this.originalOptions);
options.view.chain = undefined;
options.view.image = image;
this.apiCall = "loadImage";
this.initialize(this.parent, options);},
legacyCollectionStartup: function(lf){
var glassDim = prototype$(this.savedStartupValues.b).getDimensions();
var parent = this.savedStartupValues.a;
var options = {
server:	lf.getServer(),
uri:	lf.getURI(),
port:	lf.getPort(),
view: {
chain: undefined,
width: this.savedStartupValues.d,
height: this.savedStartupValues.d,
href: this.savedStartupValues.e.url || ""},
magnifiedView: {
mode: this.savedStartupValues.e.zoomToPoint ? "follow" : "fixed",
id: this.savedStartupValues.b,
magnification: 0,
height: glassDim.height,
width: glassDim.width,
borderColor: this.savedStartupValues.e.focusBorderColor || "#777",
easingEnabled: true},
viewfinder: {
hideMousePointer: $DEF(this.savedStartupValues.e.hideMousePointer) ? this.savedStartupValues.e.hideMousePointer : true,
overlayEnabled: true,
overlayOptions: {
color: this.savedStartupValues.e.focusColor || "#FFF",
opacity: this.savedStartupValues.e.focusOpacity ? (this.savedStartupValues.e.focusOpacity / 100) : 0.5}}}
this._initialize(parent, options);},
whoAmI: function(){
return "magnify";},
isReady: function(){
if (this.frame && this.frame.engine){
return this.frame.engine.isReady();
}else{
return false;}},
viewPane:	undefined,
frame:		undefined,
options:	undefined,
busy:		undefined,
initialize: function(a, b, c, d, e){ //Deal with legacy - imageID, glassID, chain, size, options
if (a && b && c && d && e){
var glassDim = prototype$(b).getDimensions();
var parent = a;
var options = {
server:	c.getServer(),
uri:	c.getURI(),
port:	c.getPort(),
view: {
chain: c,
width: d,
height: d,
href: e.url || ""},
magnifiedView: {
mode: e.zoomToPoint ? "follow" : "fixed",
id: b,
magnification: 0,
height: glassDim.height,
width: glassDim.width,
borderColor: e.focusBorderColor || "#777",
easingEnabled: true},
viewfinder: {
hideMousePointer: $DEF(e.hideMousePointer) ? e.hideMousePointer : true,
overlayEnabled: true,
overlayOptions: {
color: e.focusColor || "#FFF",
opacity: e.focusOpacity ? (e.focusOpacity / 100) : 0.5}}}
this._initialize(parent, options);
}else if (a && b && d && e){
this.savedStartupValues = {
a: a,
b: b,
d: d,
e: e};
return
}else{
this._initialize(a, b);}},
_initialize: function(parent, options) {
this.parent = parent;
this.options = {};
this.setDefaults();
Object.extend(this.options, options);
this.initializeAdvancedOptions();
this.originalOptions = Object.deepClone(this.options);
try{
if(typeof(parent) === "string") {
this.viewPane = new com.liquidpixels.wui.Pane(this, {
incID:			parent});
} else if(typeof(parent) === "object") {
this.viewPane = parent;
}else{
throw new com.liquidpixels.wui.Exception({
message: "No valid element to put LiquidPixels Magnify"});}
this.checkRequired();
}catch(e){
this.handleFrameError({
response: "error",
data: {
message: e.message}});
if (this.viewPane){
if (this.options.view && this.options.view.width && this.options.view.height){
this.viewPane.setStyle({
width: this.options.view.width + "px",
height: this.options.view.height + "px"});
}else if (this.options.view && this.options.view.width){
this.viewPane.setStyle({
width: this.options.view.width + "px",
height: this.options.view.width + "px"});
}else if (this.options.view && this.options.view.height){
this.viewPane.setStyle({
width: this.options.view.height + "px",
height: this.options.view.height + "px"});
}else{
this.viewPane.setStyle({
width: "200px",
height: "200px"});}
this.viewPane.setStyle({
background: "url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxzdmcgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8IS0tIENyZWF0ZWQgd2l0aCBNZXRob2QgRHJhdyAtIGh0dHA6Ly9naXRodWIuY29tL2R1b3BpeGVsL01ldGhvZC1EcmF3LyAtLT4KCiA8Zz4KICA8dGl0bGU+YmFja2dyb3VuZDwvdGl0bGU+CiAgPHJlY3QgZmlsbD0ibm9uZSIgaWQ9ImNhbnZhc19iYWNrZ3JvdW5kIiBoZWlnaHQ9IjIwMiIgd2lkdGg9IjIwMiIgeT0iLTEiIHg9Ii0xIi8+CiAgPGcgZGlzcGxheT0ibm9uZSIgaWQ9ImNhbnZhc0dyaWQiPgogICA8cmVjdCBmaWxsPSJ1cmwoI2dyaWRwYXR0ZXJuKSIgc3Ryb2tlLXdpZHRoPSIwIiB5PSIwIiB4PSIwIiBoZWlnaHQ9IjEwMCUiIHdpZHRoPSIxMDAlIiBpZD0ic3ZnXzEiLz4KICA8L2c+CiA8L2c+CiA8Zz4KICA8dGl0bGU+TGF5ZXIgMTwvdGl0bGU+CiAgPHBhdGggc3Ryb2tlLXdpZHRoPSIwIiBpZD0ic3ZnXzIiIGQ9Im0xMDAsMi42NjcwMWMtNTMuNzUyOTMsMCAtOTcuMzMyOTksNDMuNTcyMTYgLTk3LjMzMjk5LDk3LjMzMjk5czQzLjU4MDA0OSw5Ny4zMzI5OTMgOTcuMzMyOTksOTcuMzMyOTkzYzUzLjc2MDgzNCwwIDk3LjMzMjk5MywtNDMuNTcyMTU5IDk3LjMzMjk5MywtOTcuMzMyOTkzcy00My41NzIxNTksLTk3LjMzMjk5IC05Ny4zMzI5OTMsLTk3LjMzMjk5em0wLDIzLjY3NjIzMWMxNC42MDgyMzEsMCAyOC4xOTA1MDYsNC4zMjQ4NiAzOS42NDk3OTYsMTEuNjgwMjgxbC0xMDEuNjI2MjY2LDEwMS42MjYyNzRjLTcuMzYzMzEsLTExLjQ1OTI5IC0xMS42ODAyNzksLTI1LjA0OTQ0NiAtMTEuNjgwMjc5LC0zOS42NDk3OTZjMCwtNDAuNjEyNjI5IDMzLjA0NDEyOCwtNzMuNjU2NzU5IDczLjY1Njc1NywtNzMuNjU2NzU5bC0wLjAwMDAwOCwwem0wLDE0Ny4zMTM1NDNjLTE0LjYwMDM0OSwwIC0yOC4xOTA1MTQsLTQuMzI0ODc1IC0zOS42NDk3OTIsLTExLjY4MDI4M2wxMDEuNjE4Mzc0LC0xMDEuNjI2MjgyYzcuMzYzMzEyLDExLjQ1OTI4MiAxMS42ODAyOTgsMjUuMDQ5NDU0IDExLjY4MDI5OCwzOS42NDk4MDNjMC4wMDc4ODksNDAuNjEyNjE3IC0zMy4wMzYyNTUsNzMuNjU2NzYxIC03My42NDg4OCw3My42NTY3NjF6IiBzdHJva2Utb3BhY2l0eT0ibnVsbCIgc3Ryb2tlPSIjRkZGIiBmaWxsPSIjOTk5OTk5Ii8+CiA8L2c+Cjwvc3ZnPg==') center/contain no-repeat"});}
return;}
this.resizeInfo = {
type: this.options.view.chain ? "chain" : "image",
content: this.options.view.chain ? this.options.view.chain : this.options.view.image}
this.options.apiCall = this.apiCall;
this.busy = true;
this.buildFrame();
this.blankFunctionBinder = function(e){}.bind(this);
Event.observe(window, "touchstart", this.blankFunctionBinder);
this.currentWindowHeight = document.viewport.getHeight();
this.currentWindowWidth = document.viewport.getWidth();
this.resizeHandlerBinder = function(e){
var windowHeight = document.viewport.getHeight();
var windowWidth = document.viewport.getWidth();
if (this.isReady() && (this.currentWindowHeight != windowHeight ||
this.currentWindowWidth != windowWidth)) {
clearTimeout(this.resizeHandlerTimeout);
this.resizeHandlerTimeout = setTimeout(this.resizeHandler.bind(this), 250);
this.currentWindowHeight = windowHeight;
this.currentWindowWidth = windowWidth;}
}.bind(this);
if (!this.options.advancedOptions.disableResizeListener) {
Event.observe(window, "resize", this.resizeHandlerBinder);}},
setDefaults: function() {
Object.extend(this.options, {});},
checkRequired: function(){
if (this.options.server &&
this.options.uri &&
this.options.view &&
this.options.view.width &&
this.options.view.height){
if (this.options.magnifiedView && this.options.magnifiedView.id) {
var type = com.liquidpixels.utilities.typeOf(this.options.magnifiedView.id);
var idElement;
if (type == "String") {
idElement = prototype$(this.options.magnifiedView.id);
}else{
idElement = this.options.magnifiedView.id;}
if (!idElement || !idElement.appendChild) {
throw new com.liquidpixels.wui.Exception({
message: "magnifiedView.id is not a valid HTML Element"});
}else {
idElement.hide();}}
}else{
throw new com.liquidpixels.wui.Exception({
message: "All required options for LiquidPixels Magnify are not valid"});}},
buildFrame: function() {
this.frame = new com.liquidpixels.magnify.Frame(this, this.options);
this.prepareFrame();
this.frame.startIframe();},
prepareFrame: function() {
this.viewPane.appendChild(this.frame);
this.frame.addEventListener(this.frame.events.started, this.handleFrameEvent.bind(this));
this.frame.addEventListener(this.frame.events.ready, this.handleFrameEvent.bind(this));
this.frame.addEventListener(this.frame.events.loaded, this.handleFrameEvent.bind(this));
this.frame.addEventListener(this.frame.events.magnifyStarted, this.handleFrameEvent.bind(this));
this.frame.addEventListener(this.frame.events.magnifyEnded, this.handleFrameEvent.bind(this));
this.frame.addEventListener(this.frame.events.error, this.handleFrameError.bind(this));},
handleFrameEvent: function(e) {
this.busy = false;
if(this.options.handleEvent) {
this.options.handleEvent(e.response, e.data);}},
handleFrameError: function(e) {
if(this.options.handleError) {
this.options.handleError(e.response, e.data);}
if(this.options.handleEvent) {
this.options.handleEvent(e.response, e.data);}},
initializeAdvancedOptions: function(){
var advancedOptions = {
disableResizeListener: false};
if ($DEF(this.options.advancedOptions)) {
Object.extend(advancedOptions, this.options.advancedOptions);}
this.options.advancedOptions = Object.deepClone(advancedOptions);},
resizeHandler: function(e){
if (this.resizeInfo) {
if (this.resizeInfo.type == "chain") {
this.loadChain(this.resizeInfo.content);
}else{
this.loadImage(this.resizeInfo.content)}}},
DESTROY: function() {
Event.stopObserving(window, this.blankFunctionBinder);
clearTimeout(this.resizeHandlerTimeout);
Event.stopObserving(window, this.resizeHandlerBinder);
this.resizeInfo = undefined;
if (this.viewPane){
this.viewPane.destroyChildren();
this.viewPane = null;
this.frame = null;}},
toString: function() { return "com.liquidpixels.magnify.Magnify"}});
com.liquidpixels.utilities.DeepMerge.object = function(destination, source, options) {
options = options || {};
var clone = {};
if(options.extendDestination) {
clone = destination;
} else {
for (var property in destination){
clone[property] = destination[property];}}
for (var property in source){
clone[property] = com.liquidpixels.utilities.DeepMerge.value(destination[property], source[property], options);}
return clone;};
com.liquidpixels.utilities.DeepMerge.array = function(destination, source, options) {
options = options || {};
var clone = [];
if(options.extendDestination) {
clone = destination;
} else {
for(var i=0; i<destination.length; i++) {
clone[i] = destination[i];}}
for(var i=0; i<source.length; i++) {
clone[i] = com.liquidpixels.utilities.DeepMerge.value(destination[i], source[i], options);}
return clone;};
com.liquidpixels.utilities.DeepMerge.extend = function(destination, source, options) {
options = options || {};
options.extendDestination = true;
com.liquidpixels.utilities.DeepMerge.object(destination, source, options);};
com.liquidpixels.utilities.DeepMerge.clone = function(source, options) {
options = options || {};
options.extendDestination = false;
return com.liquidpixels.utilities.DeepMerge.object({}, source, options);};
com.liquidpixels.utilities.DeepMerge.value = function(destination, source, options) {
var type = com.liquidpixels.utilities.typeOf;
if(type(destination) == "Array" && type(source) == "Array" && !options.overrideArrays) {
return com.liquidpixels.utilities.DeepMerge.array(destination, source, options);
} else if (source && type(source) == "Array"){
return com.liquidpixels.utilities.DeepMerge.array([], source, options);
} else if(destination && type(destination) == "Object" && source && type(source) == "Object") {
return com.liquidpixels.utilities.DeepMerge.object(destination, source, options);
} else if (options.extendDestination){ //We do this so we can still keep object pointers for extend.
return source;
}else{
if(source && type(source) == "Object") {
return com.liquidpixels.utilities.DeepMerge.object({}, source, options);
} else {
return source;}}};
com.liquidpixels.application.Exception = Class.create(com.liquidpixels.Exception, {
type: 		'Application.Exception'	// static, final
});
com.liquidpixels.application.Exception.DelegateNotDefined = Class.create(com.liquidpixels.application.Exception, {
type: 		'Application.DelegateNotDefined'	// static, final
});
com.liquidpixels.application.Event = Class.create(com.liquidpixels.event.TypedEvent, {
type: 		'Application.Event'	// static, final
});
com.liquidpixels.wui.Exception = Class.create(com.liquidpixels.Exception, {
type: 			'wui.Exception'	// static, final
});
com.liquidpixels.wui.Event = Class.create(com.liquidpixels.event.TypedEvent, {
type: 		'WUI.Event'	// static, final
});
com.liquidpixels.application._UniversalListeners = new Hash();
com.liquidpixels.application.EventManageable = Class.create(com.liquidpixels.Mixable, {
revision: "$Revision: 6630 $",
Version: function() {
return revision.substr(11).substr(0, -2);},
events:					undefined,
exceptions:				undefined,
handlers:				undefined,
listeners:				undefined,
universalListeners:     undefined,
prepare: function() {
this.events			= new Hash();
this.handlers		= new Hash();
this.exceptions		= new Hash();
this.listeners		= new Hash();			// hears only with ref
this.acuteListeners		= new Hash();		// hears all types...
this.universalListeners		= new Hash();	// hears without ref
if(this.options.fires) {
$H(this.options.fires).each(function(pair) {
this.addEventClass(pair.key, pair.value);});}
if(this.options.handles) {
$H(this.options.handles).each(function(pair) {
this.addHandler(pair.key, pair.value);});}
if(this.options.throws) {
$H(this.options.throws).each(function(pair) {
this.addException(pair.key, pair.value);});}
if(this.options.legacy) {
this.addLegacySet();}},
setDefaults: function() {
this.mixName = 'EventManageable';},
getException: function(exception) {
if(!exception.type) { return null; }
var exc = this.exceptions.get(exception.type) || com.liquidpixels.Exception;
var exi = new exc(exception);
return exi;},
addException: function(exceptionType, exceptionClass) {
this.exceptions.set(exceptionType, exceptionClass);},
throwException: function(exception) {
var ex = this.getException(exception);
throw ex;},
dispatch: function(event, handler) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this; }
if(handler) {
var hQ = new Array(handler);
this.broadcastTo(hQ, event);
} else {
var eType = event.type || "Untyped";
var rQ = this.listeners.get(eType);
if(rQ) { this.broadcastTo(rQ, event); }
var uQ = com.liquidpixels.application._UniversalListeners.get(eType);
if(uQ) { this.broadcastTo(uQ, event); }
var aQ = this.acuteListeners.get("__ALL_EVENTS__");
if(aQ) { this.broadcastTo(aQ, event); }}},
dispatchUniversal: function(event) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this.target; }
var eType = event.type || "Untyped";
var uQ = com.liquidpixels.application._UniversalListeners.get(eType);
if(uQ) { this.broadcastTo(uQ, event); }},
dispatchRegistered: function(event) {
if(!event) { return; }
if( event.ignore) { return;	}
if(!event.target) { event.target = this.target; }
var eType = event.type || "Untyped";
var rQ = this.listeners.get(eType);
if(rQ) { this.broadcastTo(rQ, event); }},
broadcastTo: function(queue, event) {
if(!event) { return; }
if(!queue) { return; }
var uEvent;
var eventData = this.events.get(event.type);
if(eventData) {
var eventClass = eventData.eventClass || this.options.defaultEvent;
if(eventClass) {
Object.extend(eventData, event);
uEvent = new eventClass(this.target, eventData);
} else {
uEvent = event;}
} else {
uEvent = event;}
queue.each(function(o, i) {
if(o.func) {
o.func(uEvent);
} else if(o.handler) {
var func = o.handler.EventManageable.handlers.get(event.type);
if(func) {func(uEvent)};}});},
addListenerTo: function(listeners, eventType, handler, bindVar) {
if(!listeners) { return; }
if(!eventType) { return; }
if(!handler) { return; }
var q = listeners.get(eventType) ||
listeners.set(eventType, new Array());
var localQueue;
if (listeners === com.liquidpixels.application._UniversalListeners){
var localQueue = this.universalListeners.get(eventType) || this.universalListeners.set(eventType, new Array());}
var addToQ = true;
q.each(function(o,i) {
if(handler === o.handler) {
addToQ = false;
return;}});
if(addToQ) {
var func;
if(typeof(handler.handle) === 'function') {
func = handler.handle;
} else if(typeof(handler) === 'function') {
if(bindVar) {
func = handler.bind(bindVar);
} else {
func = handler;}}
var data = {
handler: handler,
bindVar: bindVar,
func:	 func};
q.push(data);
if (localQueue){
localQueue.push(data);}}},
removeListenerFrom: function(listeners, eventType, handler) {
if(!listeners) { return; }
if(!eventType) { return; }
var q = listeners.get(eventType);
if (!q) { return; }
var localQueue;
if (listeners === com.liquidpixels.application._UniversalListeners){
localQueue = this.universalListeners.get(eventType);}
if(handler) {
q.each(function(o,i) {
if(handler === o || handler === o.handler) {
listeners.set(eventType,(q).without(o));
if (localQueue){
this.universalListeners.set(eventType, (localQueue).without(o));}
return;}
}.bind(this));
} else {
listeners.unset(eventType);
if (listeners === com.liquidpixels.application._UniversalListeners){
this.universalListeners.unset(eventType);}}},
addListener: function(eventType, handler, bindVar)	{
this.addListenerTo(this.listeners, eventType, handler, bindVar);},
addAcuteListener: function(handler, bindVar) {
this.addListenerTo(this.acuteListeners, '__ALL_EVENTS__', handler, bindVar);},
addUniversalListener: function(eventType, handler, bindVar)	{
this.addListenerTo(com.liquidpixels.application._UniversalListeners, eventType, handler, bindVar);},
addListeners: function(eventTypes, handlers, bindVar) {
$A(eventTypes).each(function(eo,ei) {
$A(handlers).each(function(ho,hi) {
this.addListenerTo(this.listeners, eo, ho, bindVar);
}.bind(this))
}.bind(this));},
addUniversalListeners: function(eventTypes, handlers, bindVar) {
$A(eventTypes).each(function(eo,ei) {
$A(handlers).each(function(ho,hi) {
this.addListenerTo(com.liquidpixels.application._UniversalListeners, eo, ho, bindVar);
}.bind(this))
}.bind(this));},
removeListener: function(eventType, handler) {
this.removeListenerFrom(this.listeners, eventType, handler);},
removeAcuteListener: function(handler) {
this.removeListenerFrom(this.acuteListeners, '__ALL_EVENTS__', handler);},
removeUniversalListener: function(eventType, handler) {
this.removeListenerFrom(com.liquidpixels.application._UniversalListeners, eventType, handler);},
observe: function(eventType, object) {
if(object && object.EventManageable) {
(object.EventManageable).addListener(eventType, this);
} else {
this.addUniversalListener(eventType);}},
addEventClass: function(eventType, eventClass) {
this.events.set(eventType, eventClass);},
removeEventClass: function(eventType) {
this.events.unset(eventType);},
addHandler: function(eventType, handler) {
this.handlers.set(eventType, handler);},
addHandlers: function(handles) {
$H(handles).each(function(pair) {
this.addHandler(pair.key, pair.value);});},
removeHandler: function(eventType) {
return ( this.handlers.unset(eventType) );},
getHandler: function(eventType) {
return ( this.handlers.get(eventType) );},
handle: function(e) {
if(e.ignore) { return; }
var fn = this.handlers.get(e.type);
if(typeof(fn) === "function") {
fn(e);}},
report: function(e) {
_console.debug("Event: %o (%o) on %o (%s)", e.type, e, e.target, e.description);},
notify: function(e) {
this.handle(e);},
prepareExportList: function($super) {
$super(['listeners', 'events', 'handling', 'acuteListeners',
'dispatch', 'dispatchUniversal', 'dispatchRegistered',
'broadcastTo', 'addListenerTo', 'removeListenerFrom',
'addListener',  'addUniversalListener', 'addAcuteListener',
'addListeners', 'addUniversalListeners',
'removeListener', 'removeUniversalListener', 'removeBlindEventListener',
'removeAcuteListener',
'observe', 'addEventClass', 'removeEventClass',
'addHandler', 'removeHandler', 'getHandler',
'handle', 'report', 'notify',
'exceptions', 'getException', 'throwException', 'addLegacySet', 'destroyListeners'
]);},
addLegacySet: function() {
this.target.dispatchEvent = this.dispatch.bind(this);
this.target.addEventListener = this.addListener.bind(this);
this.target.addEventListeners = this.addListeners.bind(this);
this.target.removeEventListener = this.removeListener.bind(this);
this.target.removeBlindEventListener = this.removeUniversalListener.bind(this);
this.target.dispatchBlindEvent =  this.dispatchUniversal.bind(this);
this.target.addBlindEventListener =  this.addUniversalListener.bind(this);
this.target.addUIEventHandler = this.addHandler.bind(this);
this.target.handleUIEvent = this.handle.bind(this);
this.target.reportUIEvent = this.report.bind(this);
this.target.notifyEvent = this.notify.bind(this);},
destroyListeners: function(){
var uListerners = this.universalListeners.clone();
uListerners.each(function(pair){
pair.value.each(function(o,i){
this.removeUniversalListener(pair.key, o.handler);
}.bind(this));
}.bind(this));
var localListeners = this.listeners.clone();
localListeners.each(function(pair){
pair.value.each(function(o,i){
this.removeListener(pair.key, o.handler);
}.bind(this));
}.bind(this));
var acuteListeners = this.acuteListeners.clone();
acuteListeners.each(function(pair){
pair.value.each(function(o,i){
this.removeAcuteListener(o.handler);
}.bind(this));
}.bind(this));},
clearEvents: function($super) {
this.destroyListeners();
$super();},
toString: function() {
return "com.liquidpixels.application.EventManageable";}});
com.liquidpixels.event.EventDispatcher.makeDispatcher = function(target, options) {
com.liquidpixels.Mixable.applyTo(target, com.liquidpixels.application.EventManageable, (options || {}));
target.EventManageable.addLegacySet();
target.EventManageable.prepare();};
com.liquidpixels.event.EventManageable.applyTo = function(target, options) {
com.liquidpixels.Mixable.applyTo(target, com.liquidpixels.application.EventManageable, (options || {}));
target.EventManageable.prepare();};
com.liquidpixels.wui.UIComponent = Class.create(com.liquidpixels.Basic, {
id:						undefined,
element:				undefined,
visualStates:			undefined,
currentVisualState:		undefined,
enabled:				undefined,  // can mouse
visible:				undefined,  // can see
posX:					undefined,
posY:					undefined,
width:					undefined,
height:					undefined,
preLoadedIntoDOM:		undefined,
notAppendable:			undefined, // easy check...
initialize: function($super, parent, options) {
this.options = {
tagType:			'div',
uicNspace:			'uic_',
visible:			true,
defaultCssClass:	''};
$super(parent, options);
if(typeof com.liquidpixels.wui._UIComponent == 'undefined') {
com.liquidpixels.wui._UIComponent = {
elements:	new Hash(),
id:			0,
counted:	0};}
if(this.options.id) {
this.id = this.options.id;
if( com.liquidpixels.wui._UIComponent.elements.get(this.id) ) {
this.errorBadID();
return;
} else if( this.options.element ) {
if(this.options.element.id && prototype$(this.options.element.id) ) {
this.preLoadedIntoDOM = true;}
this.element = this.options.element;
if (this.id != this.options.element.id) {
this.element.setAttribute("id", this.id);}
} else {
if( prototype$(this.options.id) ) {
this.errorBadElement();
return;
} else {
this.element = this._createElement();}}
} else if(this.options.incID) {
this.id = this.options.incID;
this.element = prototype$(this.id);
this.preLoadedIntoDOM = true;
if( !this.element ) {
this.errorIncID();}
} else { // no id
this.id = this.makeID();
if( prototype$(this.id) ) {
this.errorBadElement();
return;}
if(this.options.element) {
this.element = this.options.element;
this.preLoadedIntoDOM = true;
this.element.setAttribute("id", this.id);
} else {
this.element = this._createElement();}}
com.liquidpixels.wui._UIComponent.elements.set(this.id, this);
com.liquidpixels.wui._UIComponent.counted++;
if(!this.element) { return; }
var theSrc = this.options.imgSrc || this.options.src;
if(theSrc) { this.setSrc(theSrc); }
this.setStyle(this.options.cssStyle);
if(this.options.defaultCssClass) {
this.setCssClass(this.options.defaultCssClass);}
if(this.options.cssClass) {
this.addClassName(this.options.cssClass);}
this.setAttributes(this.options.attributes);
this.prepareElement();
this.prepareVisible();
this.prepareEnabled();
this.visualStates = this.options.visualStates || {};
if(this.preLoadedIntoDOM) {
this.postAppendChild();}
var domParent = this.options.domParent;
if(domParent) {
if(this.preLoadedIntoDOM) {
if(domParent.incChild) {
domParent.incChild(this);}
} else {
if(domParent.appendChild) {
domParent.appendChild(this);}}}
return;},
initializeSpecific: function() { /* VIRTUAL */ },
// ALWAYS call this as $super in your subclasses or provide the info.
setDefaults:	function() { /* VIRTUAL */ },
makeID: function() {
return this.options.uicNspace + com.liquidpixels.wui._UIComponent.id++;},
setSrc: function(src) {
this.setAttribute('src', src);},
_createElement: function() {
var el;
var builder;
if(this.ElementBuilder) {
builder = this.ElementBuilder;
} else if (this.parent && this.parent.ElementBuilder) {
builder = this.parent.ElementBuilder;}
if(builder && !this.ignoreElementBuilder) {
var btype = typeof(builder);
if(btype === "function" ) {
el = builder();
} else if(btype === "object") {
el = builder.createElement();}}
if(this.parent &&
this.parent.createElement &&
!this.parent.ignoreParentCreateElement &&
typeof(this.parent.createElement) == "function") {
el = this.parent.createElement(this);}
if(!el) { el = this.createElement(this); }
return el;},
createElement: function(thingy) {
var el = new Element(thingy.options.tagType, {
id: thingy.id});
return el;},
postAppendChild: function() { /* VIRTUAL */ },
wasPreloadedIntoDOM: function() {
return  !!( this.preLoadedIntoDOM );},
prepareElement: function() {},
prepareVisible: function() {
if(this.options.visible) {
this.visible = true;
} else {
this.visible = false;
this.setVisible(this.visible);}},
prepareEnabled: function() {
this.enabled = $NVL(this.options.enabled, true);},
setAttribute: function (attrib, value) {
if($DEF(value)) {
this.element.setAttribute(attrib, value);}},
setAttributes: function(attHash) {
if(attHash) {
$H(attHash).each(function(o) {
if($DEF(o.value)){
this.element.setAttribute(o.key, o.value);}
}.bind(this));}},
getAttribute: function (attrib) {
return this.element.readAttribute(attrib);},
removeAttribute: function(attrib){
this.element.removeAttribute(attrib);},
getValues: function() {	},
setMetadataItem: function(object){
Element.store(this.element, object);},
getMetadataItem: function(key){
return Element.retrieve(this.element, key);},
getMetadata: function(){
return Element.getStorage(this.element);},
makeUnselectable: function() {
this.element.onselectstart = function() { return false; };
this.element.style.MozUserSelect = "none";
this.element.style.KhtmlUserSelect = "none";
this.element.unselectable = "on";},
getDimensions: function() {
return this.element.getDimensions();},
getOffsetPosition: function() {
return this.element.positionedOffset();},
setPosition: function(left, top, opts) {
var vals = this.updatePositionValues(left, top, opts);
this.setStyle(vals);},
updatePositionValues: function(left, top, opts) {
var vals = {};
if(left || left === 0) {
if(!(opts && opts.tweening)) {
this.posX = left;}
vals.left = left + "px";}
if(top || top === 0) {
if(!(opts && opts.tweening)) {
this.posY = top;}
vals.top = top + "px";}
return vals;},
getPosition: function() {
var pos = {
left:	this.posX,
top:	this.posY,
x:		this.posX,
y:		this.posY};
return pos;},
setSize: function(w,h,opts) {
var style = {};
opts = opts || {};
if(w || w === 0) {
if(!opts.tweening) { this.width  = w; }
style.width = w + "px";}
if(h || h === 0) {
if(!opts.tweening) { this.height = h; }
style.height = h + "px";}
this.setStyle(style);},
getSize: function() {
var dims = {
width:	this.width,
height:	this.height};
return dims;},
resize: function(scale) {
if(this.height) { // skips 0, too
this.height *= scale;}
if(this.width) {
this.width *= scale;}},
reposition: function(addX, addY) {
this.posX += addX;
this.posY += addY;},
appendChild: function(child) {
var thingy = child;
if(typeof child == "object" && child.element) {
thingy = child.element;}
this.element.insert(thingy);},
appendValue: function(value) {
this.appendChild(value);},
setValue: function(content) {
this.element.update(content);},
getValue: function() {
return this.element.innerHTML;},
destroyChildren: function() {
var inner = this.element.innerHTML;
this.element.update();
return inner;},
removeChildren: function() { return this.destroyChildren() },
setStyle: function(style) {
var typeofStyle = typeof(style);
if(typeofStyle == 'string') {
this.setAttribute("style", style);
} else if(typeofStyle == 'object') {
this.element.setStyle(style);
} else {}},
setCssClass: function(css) {
this.setAttribute("class", css);},
getStyle: function (attrib) {
return this.element.getStyle(attrib);},
getStyles: function() {
var cssStyle = this.element.style;
var styles = new Hash();
for(var i = 0; i < cssStyle.length; i++) {
var key = cssStyle.item(i);
styles.set(key, cssStyle.getPropertyValue(key));}
return styles;},
addClassName: function(className) {
this.element.addClassName(className);},
hasClassName: function(className) {
return this.element.hasClassName(className);},
removeClassName: function(className) {
this.element.removeClassName(className);},
errorBadElement: function(elm) {
throw new com.liquidpixels.Exception({
message: "ERR: This element in use; must destroy it first: '" + this.id + "'",
target: this});},
errorBadID: function() {
throw new com.liquidpixels.Exception({
message: "ERR: This id in use; must destroy it first: '" + this.id+ "'",
target: this});},
errorIncID: function() {
throw new com.liquidpixels.Exception({
message: "ERR: This include not found: '" + this.id+ "'",
target: this});},
getVisible: function() {
return ( this.visible );},
isVisible: function() { return this.getVisible(); },
setVisible:  function(isVisible) {
if(isVisible) {
this.show();
} else {
this.hide();}},
addTip: function(content, title, options){
try{
return this.element.addTip(content, title, options);
}catch(e){
new com.liquidpixels.Exception({
message: e.type + ' - Opentip is not installed correctly',
target: this});}},
show: function() {
this.element.show();
this.visible = true;
return this.element;},
hide: function() {
this.element.hide();
this.visible = false;
return this.element;},
fade: function(opts) {
Effect.Fade(this.element, opts);
this.visible = false;},
appear: function(opts) {
Effect.Appear(this.element, opts);
this.visible = true;},
getEnabled: function() {
return ( this.enabled );},
isEnabled: function() { return this.getEnabled(); },
enable: function() {
this.setEnabled(true);},
disable: function() {
this.setEnabled(false);},
setEnabled: 	function(isEnabled) { /* VIRTUAL */ },
isLocked: function() {
if( this.options.lockOnStatus && (typeof(Application) !== 'undefined') && Application.status && Application.status.isBusy() ) {
return true;
} else {
return ( !this.enabled );}},
setLockOnStatus: function(val) {
this.options.lockOnStatus = !!(val);},
update: 		function() { },
clearEvents: function() { /* VIRTUAL */ },
// Handles ['CLR', 'SET', 'OVR', 'SOV', 'DWN', 'SDW']
applyStyle: function(styleState) {
var cssOver = this.options.cssOver || 'selOver';
var cssSel = this.options.cssSelected || 'selected';
switch(styleState) {
case "OVR":
Element.addClassName(this.element, cssOver);
break;
case 'DWN':	case 'SDW':
Element.addClassName(this.element, cssSel);
break;
case 'SOV':
Element.addClassName(this.element, cssSel);
Element.addClassName(this.element, cssOver);
break;
case 'SET':
Element.addClassName(this.element, cssSel);
Element.removeClassName(this.element, cssOver);
break;
default: // CLR...
Element.removeClassName(this.element, cssSel);
Element.removeClassName(this.element, cssOver);}},
DESTROY: 		function() {
this.clearEvents();
com.liquidpixels.wui._UIComponent.elements.unset(this.id);
var u = prototype$(this.id) || this.element;
if( u && u.parentNode ) {
u.parentNode.removeChild(u);}
this.element = null;
return this;},
toHTML: function(opts) {
if(!opts) {opts = {}};
var html = com.liquidpixels.wui.UIComponent.elementToHTML(this.element, opts);
return html;},
getNodeName: function() {
return this.element.nodeName;},
toString: function() { return 'com.liquidpixels.wui.UIComponent'; }});
com.liquidpixels.wui.UIComponent.destroy = function(uic) {
if(uic.DESTROY)
uic.DESTROY();
uic = null;};
com.liquidpixels.wui.UIComponent.getCurrentCount = function() {
var cnt = com.liquidpixels.wui._UIComponent.elements.keys().length;
return cnt;};
com.liquidpixels.wui.UIComponent.getCreatedCount = function() {
var cnt = com.liquidpixels.wui._UIComponent.counted;
return cnt;};
com.liquidpixels.wui.UIComponent.getElement = function(uid) {
return ( com.liquidpixels.wui._UIComponent.elements.get(uid) );};
var $UIC = function (parent, type, id, cssClass, value) {
var opts = {};
if(type) { opts.tagType = type; }
if(id) { opts.id = id; }
if(cssClass) { opts.cssClass = cssClass; }
var u = new com.liquidpixels.wui.UIComponent(parent, opts);
if($DEF(value)) { u.setValue(value) };
return u;};
com.liquidpixels.wui.UIComponent.elementToHTML = function(elemOrID, opts) {
var element = (typeof(elemOrID) == 'string' ? $(elemOrID) : elemOrID);
opts = opts || {};
var nodeName = (opts.nodeName || element.nodeName);
var html = '<' + nodeName;
$A(element.attributes).each(function(o,i) {
var name = o.nodeName;
var val = $NVL(o.nodeValue, "").toString();
if(val != "" && (opts.keepFunctions || !val.match("^function()"))) {
html += ' ' + name + '="' + val + '"';}});
if(opts.closing == 'slash') {
html += ' /';
} else if(opts.closing == 'tag') {
html += '</ ' + nodeName;}
html += '>';
return html;};
com.liquidpixels.wui.Pane = Class.create(com.liquidpixels.wui.UIComponent, {
children:					undefined,	// HASH of UICs
childrenOrder:              undefined, //Array of Children in order
itemRefs:					undefined,
ccElement:		undefined, // childContainerElement
initialize: function($super, parent, options) {
$super(parent, options);
this.ccElement = this.element;},
initializeSpecific: function() {
this.children = new Hash();
this.childrenOrder = new Array();
this.itemRefs = {};},
setDefaults: function() {
Object.extend(this.options, {
defaultCssClass:	"pane"});},
getChild: function(id) {
return ( this.children.get(id) );},
getChildByIndex: function(index) {
var id = this.childrenOrder[index];
return this.getChild(id);},
_appendChild: function(child, id) {
if(child.notAppendable) {
this.errorCannotAppendChild(child, id);
return;}
this._addChild(child, id);
this.childrenOrder.push(id || child.id);
if (this.ccElement) { this.ccElement.appendChild(child.element); }
child.postAppendChild();},
appendChild: function(child, id) {
this._appendChild(child, id);},
errorCannotAppendChild: function(child, id) {
var theid = id || child.id || "";
throw new com.liquidpixels.Exception({
message: "ERR: Child (" + child + ", '" + theid +"') is not appendable.",
target: child});},
insertChild: function(child, location) {
if(child.notAppendable) {
this.errorCannotAppendChild(child, id);
return;}
this._addChild(child);
if (location && typeof(location) === 'object'){
if (this.ccElement) {
this.ccElement.insert(child.element, options);}
return;}
if (this.ccElement) {
if(location === undefined || location >= this.childrenOrder.length){
this.childrenOrder = this.childrenOrder.without(child.id);
this.childrenOrder.push(child.id);
this.ccElement.insert({bottom: child.element})
}else{
var childAtLocation = this.getChildByIndex(location);
var index = this.childrenOrder.indexOf(child.id);
this.childrenOrder.splice(location,0,child.id);
if (location <= index && index !== -1){
this.childrenOrder.splice(index + 1,1);
}else if (index !== -1) {
this.childrenOrder.splice(index,1);}
if (location === 0){
this.ccElement.insert({top: child.element});
}else{
childAtLocation.element.insert({before: child.element});}}}},
_addChild: function(child, id) {
if(! id) { id = child.id; }
this.children.set(id, child);},
incChild: function(child, id) {
return this._addChild(child, id);},
_storeChild: function(child) {
this.appendChild(child);},
getScrollOffset: function(p) {
return ( p - this.element.scrollTop );},
setValue: function(content) {
var cnt = this.children.keys().length;
if(!cnt) {
this.element.update(content);}},
clearEvents: function(){
if (this.element && this.element.stopObserving){
this.element.stopObserving();}},
DESTROY: function($super) {
this.destroyChildren();
$super();},
destroyChildren: function() {
if(this.children) {
this.children.each(function(pair){
this.children.unset(pair.key);
this.childrenOrder = this.childrenOrder.without(pair.key);
pair.value.DESTROY();
pair.value = null;
}.bind(this));}},
removeChild: function(child) {
var c =  this.children.unset(child.id);
if (c && this.ccElement) {
this.childrenOrder = this.childrenOrder.without(child.id);
this.ccElement.removeChild(c.element);}
return c;},
removeChildren: function() {
var list = new Hash();
this.children.each(function(child) {
var c = this.removeChild(child.value);
this.childrenOrder = this.childrenOrder.without(child.key);
list.set(child.key, child.value);
}.bind(this));
return list;},
toString: function() {
return "com.liquidpixels.wui.Pane";}});
com.liquidpixels.wui.HTMLDoc = Class.create(com.liquidpixels.wui.Pane, {
src:					undefined,
head:					undefined,
body:					undefined,
window:					undefined,
document:				undefined,
initialize: function($super, parent, options) {
$super(parent, options);
com.liquidpixels.event.EventDispatcher.makeDispatcher(this);},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
src:	"",
onLoadEvent: 'HTMLDoc.Loaded'});},
prepare: function() {
this.createSource();
this.makeDocument();},
createSource: function() {
this.src = this.options.src || this.options.url || "";},
makeDocument: function() { /* VIRTUAL */ },
// Call only when document is loaded
prepareDocument: function() {
if(! this.document) { return; }
var htmls = this.document.getElementsByTagName('html');
if(!htmls.length) { return; }
var heads = this.document.getElementsByTagName('head');
if(heads.length) {
this.head = heads[0];
} else {
this.head = this.document.createElement('head');
htmls[0].appendChild(this.head);}
var bodies = this.document.getElementsByTagName('body');
if(bodies.length) {
this.body = bodies[0];
} else {
var framesets = this.document.getElementsByTagName('frameset');
if(framesets.length) {
this.body = framesets[0];
} else {
this.body = this.document.createElement('body');
htmls[0].appendChild(this.body);}}},
onDocLoadHandler: function(e) {
this.EventManageable.dispatch(new com.liquidpixels.wui.Event(this.options.onLoadEvent, {
target: this,
UAevent: e
}));},
onWindowLoadHandler: function() {
if(this.alreadyfiredwindohandler) {return;}
this.alreadyfiredwindohandler = true;
this.window = this.getContent();
this.document = this.window.document || this.window;
this.onDocLoadHandler();},
setValue: function(html) {
if(this.document) {
this.document.write(html);
this.window.onload = this.onWindowLoadHandler.bind(this);
this.window._onwindowloaded = this.onWindowLoadHandler.bind(this);
this.document.close();}},
appendHeadElement: function(element) {
this.head.appendChild(element);},
appendBodyElement: function(element) {
this.body.appendChild(element);},
createLinkTag: function(href) {
var tag = this.document.createElement("link");
tag.setAttribute('rel', 'stylesheet');
tag.setAttribute('type', 'text/css');
tag.setAttribute('href', href);
return tag;},
createScriptTag: function(src) {
var tag = this.document.createElement("script");
tag.setAttribute('src', src);
tag.setAttribute('type', 'text/javascript');
return tag;},
createTitleTag: function(title) {
var tag = this.document.createElement("title");
tag.innerHTML = title;
return tag;},
addScript: function(src) {
var script = this.createScriptTag(src);
this.appendHeadElement(script);},
addStyleLink: function(href) {
var lnk = this.createLinkTag(href);
this.appendHeadElement(lnk);},
setTitle: function(text){
var title = this.createTitleTag(text);
this.appendHeadElement(title);},
getWindow: function() {
return this.window;},
getDocument: function() {
return this.window.document;},
getBody: function() {
return this.body;},
getHead: function() {
return this.head;},
errorDocClosed: function() {
throw new com.liquidpixels.Exception({
message: "ERR: Document is closed, cannot append to head.",
target: this});},
toString: function() { return "com.liquidpixels.wui.HTMLDoc"; }});
com.liquidpixels.wui.IFrame = Class.create(com.liquidpixels.wui.HTMLDoc, {
initialize: function($super, parent, options) {
$super(parent, options);
this.setAttribute('scrolling', this.options.scrolling);
this.setAttribute('allowTransparency', true);
this.setStyle({scrolling: this.options.scrolling});},
setDefaults: function($super) {
$super();
Object.extend(this.options, {
src:				"",
tagType:			'iframe',
defaultCssClass:	'iframe',
scrolling:			'no'});},
postAppendChild: function() {
this.prepare();},
makeDocument: function() {
this.window = this.getContent();
if(!this.window) {
this.errorNoWindow();
return;}
this.document = this.window.document || this.window;
this.prepareSource();},
prepareSource: function() {
if(this.src) {
this.setSrc(this.src);}},
onDocLoadHandler: function($super) {
this.prepareDocument();
this.ccElement = this.body;
$super();},
postMessage: function(message) {
this.window.postMessage(message, window.location);},
getContent: function() {
var c;
if(this.element.contentWindow) {
c = this.element.contentWindow;
} else if(this.element.contentDocument) {
c = this.element.contentDocument;
} else if(window.frames[this.id]) {
c = window.frames[this.id];
} else {
return c;}
return c;},
errorNoWindow: function() {
throw new com.liquidpixels.Exception({
message: "ERR: IFrame Window not found: '" + this.id+ "'",
target: this});},
toString: function() { return "com.liquidpixels.wui.IFrame"; }});
com.liquidpixels.magnify.Frame = Class.create(com.liquidpixels.wui.IFrame, {
engine:		undefined,
events:		undefined,
html:			undefined,
baseDir:		undefined,
initialize: function($super, parent, options) {
$super(parent, options);
this.setAttributes({
frameBorder: 0});
this.setStyle({
width: this.options.view.width + "px",
height: this.options.view.height + "px"});
this.onDocLoadHandlerRetryCount = 0;
this.prepareEvents();},
prepareEvents: function() {
this.events = {
started:	"Magnify.Started",
ready:		"Magnify.Ready",
loaded:		"Magnify.Loaded",
magnifyStarted:	"Magnify.MagnifyStarted",
magnifyEnded:	"Magnify.MagnifyEnded",
waiting: 	"Magnify.Waiting",
error:		"Magnify.Error"}},
createSource: function() {
this.lf = new com.liquidpixels.liquifire.LiquiFire(this.options.server, this.options.uri, this.options.port);
var zapDir = this.lf.getZapDir();
if(!zapDir) {
this.errorNoZapDir();
return;}
var dhtmlDir = this.options.DHTMLDir || "dhtml";
this.baseDir = zapDir + "/" + dhtmlDir + "/";
var jsr = "com.liquidpixels.magnify.Engine.jsr";
var cssr = "com.liquidpixels.magnify.Engine.cssr";
var cssSrc = this.baseDir + cssr;
var scriptSrc = this.baseDir + jsr;
var userCss = "";
if(this.options.view.styleSheet) {
userCss = '   <link rel="stylesheet" href="' + this.options.view.styleSheet + '" type="text/css" /> ';}
this.html = '<!DOCTYPE html> ' +
'  <head> ' +
'   <link rel="stylesheet" href="' + cssSrc + '" type="text/css" /> ' +
userCss +
'   <script src="' + scriptSrc + '" type="text/javascript"><\/script> ' +
(this.options.domain ? '<script type="text/javascript"> window.domain = "' + this.options.domain + '";<\/script>' : "") +
' <\/head><body><\/body><\/html>';},
prepareSource: function() {
if(this.html) {
this.setValue(this.html);}},
onDocLoadHandler: function() {
this.prepareDocument();
this.onDocLoadHandlerRetryCount++
if (!this.window.Application && this.onDocLoadHandlerRetryCount < 10){
setTimeout(this.onDocLoadHandler.bind(this),100);
return;}
this.engine = this.window.Application.delegate;
this.engine.buildMagnifiedWindow = this.buildMagnifiedWindow.bind(this);
this.engine.buildOutsideOverlay = this.buildOutsideOverlay.bind(this);
this.engine.getIframeInfo = this.getIframeInfo.bind(this);
this.engine.setIframeZindex = this.setIframeZindex.bind(this);
this.engine.getScrollOffsets = this.getScrollOffsets.bind(this);
this.engine.sendEvent = this.receiveEvent.bind(this);
this.window.Application.set("lf", this.lf);
this.window.Application.set("zap.baseDir", this.baseDir);},
startIframe: function(){
if ($DEF(this.engine) && $DEF(this.engine.loadOptions)) {
this.engine.loadOptions(this.options);
}else{
setTimeout(function(){
this.startIframe();
}.bind(this),10);}},
errorNoZapDir: function() {
_console.debug("no zap dir");},
receiveEvent: function(name, data) {
this.dispatchEvent({
type: this.events[name],
response: name,
data: data});},
buildMagnifiedWindow: function(){
if ($DEF(this.engine.options.magnifiedView.id) && this.engine.options.magnifiedView.mode != "fill") {
if (typeof(this.engine.options.magnifiedView.id) == "object") {
if (!this.engine.options.magnifiedView.id.id) {
this.engine.options.magnifiedView.id.id = "lpiViewers_" + com.liquidpixels.wui._UIComponent.id++;}
this.engine.options.magnifiedView.element = prototype$(this.engine.options.magnifiedView.id.id);
}else if (typeof(this.engine.options.magnifiedView.id) == "string") {
this.engine.options.magnifiedView.element = prototype$(this.engine.options.magnifiedView.id);}
this.engine.options.magnifiedView.originalElement = this.engine.options.magnifiedView.element.cloneNode(true);
this.engine.options.magnifiedView.element.show();
var pos = this.engine.options.magnifiedView.element.getStyle("position");
if (pos != "absolute" && pos != "fixed") {
this.engine.options.magnifiedView.element.setStyle({
position: "relative"});}
this.engine.options.magnifiedView.id = (this.engine.options.magnifiedView.element ? this.engine.options.magnifiedView.element.id : undefined) || ("lpiViewers_" + com.liquidpixels.wui._UIComponent.id++);
this.engine.options.magnifiedView.width = this.engine.options.magnifiedView.element.getWidth();
this.engine.options.magnifiedView.height = this.engine.options.magnifiedView.element.getHeight();
this.engine.options.magnifiedView.borderWidth = this.parseInt(this.engine.options.magnifiedView.element.getStyle("borderLeftWidth"));
this.engine.options.magnifiedView.borderColor = this.engine.options.magnifiedView.element.getStyle("borderColor");
if (this.engine.options.magnifiedView.mode == "follow") {
this.engine.options.magnifiedView.parentElement = this.engine.options.magnifiedView.element.parentElement;
var body = document.getElementsByTagName('body') [0];
body.appendChild(this.engine.options.magnifiedView.element);
this.engine.options.magnifiedView.element.setStyle({
width: this.engine.options.magnifiedView.width + "px",
height: this.engine.options.magnifiedView.height + "px",
border: this.engine.options.magnifiedView.borderWidth + "px solid " + this.engine.options.magnifiedView.borderColor});
this.engine.options.magnifiedView.originalElement = this.engine.options.magnifiedView.element.cloneNode(true);}
}else{
if (typeof(this.engine.options.magnifiedView.id) == "object") {
prototype$(this.engine.options.magnifiedView.id.id).hide();
}else if (typeof(this.engine.options.magnifiedView.id) == "string") {
prototype$(this.engine.options.magnifiedView.id).hide();}
this.engine.options.magnifiedView.id = "lpiViewers_" + com.liquidpixels.wui._UIComponent.id++;
this.engine.options.magnifiedView.element = new Element('div', {id: "LPI_Generated_DIV"});
var body = document.getElementsByTagName('body') [0];
body.appendChild(this.engine.options.magnifiedView.element);}
this.engine.options.magnifiedView.imageContainerElement = new Element('div', {id: "LPI_Generated_DIV_1"});
this.engine.options.magnifiedView.imageElement = new Element('img', {id: "LPI_Generated_DIV_2"});},
buildOutsideOverlay: function(){
var rtn = {
element: undefined,
id: undefined};
rtn.id = "lpiViewers_" + com.liquidpixels.wui._UIComponent.id++;
rtn.element = new Element('div', {});
var body = document.getElementsByTagName('body') [0];
body.appendChild(rtn.element);
return rtn;},
getIframeInfo: function(){
var offset = this.element.cumulativeOffset();
var dimensions = this.element.getDimensions();
return {
frameLeft: offset.left,
frameTop: offset.top,
left: offset.left + this.parseInt(this.element.getStyle("borderLeftWidth")),
top: offset.top + this.parseInt(this.element.getStyle("borderTopWidth")),
width: dimensions.width,
height: dimensions.height,
offsetX: 0,
offsetY: 0};},
parseInt: function(value){
value = parseInt(value);
if (isNaN(value)){
return 0;
}else if (typeof(value) != "number"){
return 0;
}else{
return value;}},
getScrollOffsets: function(){
return document.viewport.getScrollOffsets();},
setIframeZindex: function(index){
this.setStyle({
zIndex: index});
this.parent.viewPane.element.absolutize();},
DESTROY: function($super){
if (this.engine.options.magnifiedView.parentElement) {
this.engine.options.magnifiedView.parentElement.appendChild(this.engine.options.magnifiedView.element);}
this.engine.DESTROY();
$super();},
toString: function() { return "com.liquidpixels.magnify.MagnifyFrame"; }});
com.liquidpixels.Magnify = Class.create(com.liquidpixels.magnify.Magnify, {});

